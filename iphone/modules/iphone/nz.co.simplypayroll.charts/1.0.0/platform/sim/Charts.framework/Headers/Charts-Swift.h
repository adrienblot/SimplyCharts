// Generated by Apple Swift version 2.2 (swiftlang-703.0.18.8 clang-703.0.31)
#pragma clang diagnostic push

#if defined(__has_include) && __has_include(<swift/objc-prologue.h>)
# include <swift/objc-prologue.h>
#endif

#pragma clang diagnostic ignored "-Wauto-import"
#include <objc/NSObject.h>
#include <stdint.h>
#include <stddef.h>
#include <stdbool.h>

#if !defined(SWIFT_TYPEDEFS)
# define SWIFT_TYPEDEFS 1
# if defined(__has_include) && __has_include(<uchar.h>)
#  include <uchar.h>
# elif !defined(__cplusplus) || __cplusplus < 201103L
typedef uint_least16_t char16_t;
typedef uint_least32_t char32_t;
# endif
typedef float swift_float2  __attribute__((__ext_vector_type__(2)));
typedef float swift_float3  __attribute__((__ext_vector_type__(3)));
typedef float swift_float4  __attribute__((__ext_vector_type__(4)));
typedef double swift_double2  __attribute__((__ext_vector_type__(2)));
typedef double swift_double3  __attribute__((__ext_vector_type__(3)));
typedef double swift_double4  __attribute__((__ext_vector_type__(4)));
typedef int swift_int2  __attribute__((__ext_vector_type__(2)));
typedef int swift_int3  __attribute__((__ext_vector_type__(3)));
typedef int swift_int4  __attribute__((__ext_vector_type__(4)));
#endif

#if !defined(SWIFT_PASTE)
# define SWIFT_PASTE_HELPER(x, y) x##y
# define SWIFT_PASTE(x, y) SWIFT_PASTE_HELPER(x, y)
#endif
#if !defined(SWIFT_METATYPE)
# define SWIFT_METATYPE(X) Class
#endif

#if defined(__has_attribute) && __has_attribute(objc_runtime_name)
# define SWIFT_RUNTIME_NAME(X) __attribute__((objc_runtime_name(X)))
#else
# define SWIFT_RUNTIME_NAME(X)
#endif
#if defined(__has_attribute) && __has_attribute(swift_name)
# define SWIFT_COMPILE_NAME(X) __attribute__((swift_name(X)))
#else
# define SWIFT_COMPILE_NAME(X)
#endif
#if !defined(SWIFT_CLASS_EXTRA)
# define SWIFT_CLASS_EXTRA
#endif
#if !defined(SWIFT_PROTOCOL_EXTRA)
# define SWIFT_PROTOCOL_EXTRA
#endif
#if !defined(SWIFT_ENUM_EXTRA)
# define SWIFT_ENUM_EXTRA
#endif
#if !defined(SWIFT_CLASS)
# if defined(__has_attribute) && __has_attribute(objc_subclassing_restricted)
#  define SWIFT_CLASS(SWIFT_NAME) SWIFT_RUNTIME_NAME(SWIFT_NAME) __attribute__((objc_subclassing_restricted)) SWIFT_CLASS_EXTRA
#  define SWIFT_CLASS_NAMED(SWIFT_NAME) __attribute__((objc_subclassing_restricted)) SWIFT_COMPILE_NAME(SWIFT_NAME) SWIFT_CLASS_EXTRA
# else
#  define SWIFT_CLASS(SWIFT_NAME) SWIFT_RUNTIME_NAME(SWIFT_NAME) SWIFT_CLASS_EXTRA
#  define SWIFT_CLASS_NAMED(SWIFT_NAME) SWIFT_COMPILE_NAME(SWIFT_NAME) SWIFT_CLASS_EXTRA
# endif
#endif

#if !defined(SWIFT_PROTOCOL)
# define SWIFT_PROTOCOL(SWIFT_NAME) SWIFT_RUNTIME_NAME(SWIFT_NAME) SWIFT_PROTOCOL_EXTRA
# define SWIFT_PROTOCOL_NAMED(SWIFT_NAME) SWIFT_COMPILE_NAME(SWIFT_NAME) SWIFT_PROTOCOL_EXTRA
#endif

#if !defined(SWIFT_EXTENSION)
# define SWIFT_EXTENSION(M) SWIFT_PASTE(M##_Swift_, __LINE__)
#endif

#if !defined(OBJC_DESIGNATED_INITIALIZER)
# if defined(__has_attribute) && __has_attribute(objc_designated_initializer)
#  define OBJC_DESIGNATED_INITIALIZER __attribute__((objc_designated_initializer))
# else
#  define OBJC_DESIGNATED_INITIALIZER
# endif
#endif
#if !defined(SWIFT_ENUM)
# define SWIFT_ENUM(_type, _name) enum _name : _type _name; enum SWIFT_ENUM_EXTRA _name : _type
# if defined(__has_feature) && __has_feature(generalized_swift_name)
#  define SWIFT_ENUM_NAMED(_type, _name, SWIFT_NAME) enum _name : _type _name SWIFT_COMPILE_NAME(SWIFT_NAME); enum SWIFT_COMPILE_NAME(SWIFT_NAME) SWIFT_ENUM_EXTRA _name : _type
# else
#  define SWIFT_ENUM_NAMED(_type, _name, SWIFT_NAME) SWIFT_ENUM(_type, _name)
# endif
#endif
#if defined(__has_feature) && __has_feature(modules)
@import ObjectiveC;
@import CoreGraphics;
@import UIKit;
@import Foundation;
#endif

#pragma clang diagnostic ignored "-Wproperty-attribute-mismatch"
#pragma clang diagnostic ignored "-Wduplicate-method-arg"
@protocol IChartDataSet;
enum AxisDependency : NSInteger;
@class ChartHighlight;
@class ChartDataEntry;
@class UIColor;
@class NSNumberFormatter;
@class UIFont;

SWIFT_CLASS("_TtC6Charts9ChartData")
@interface ChartData : NSObject
- (nonnull instancetype)init OBJC_DESIGNATED_INITIALIZER;
- (nonnull instancetype)initWithXVals:(NSArray<NSObject *> * _Nullable)xVals dataSets:(NSArray<id <IChartDataSet>> * _Nullable)dataSets OBJC_DESIGNATED_INITIALIZER;
- (nonnull instancetype)initWithXVals:(NSArray<NSObject *> * _Nullable)xVals;
- (nonnull instancetype)initWithXVals:(NSArray<NSObject *> * _Nullable)xVals dataSet:(id <IChartDataSet> _Nullable)dataSet;

/// Call this method to let the ChartData know that the underlying data has changed. Calling this performs all necessary recalculations needed when the contained data has changed.
- (void)notifyDataChanged;

/// \returns  the number of LineDataSets this object contains
@property (nonatomic, readonly) NSInteger dataSetCount;

/// \returns  the smallest y-value the data object contains.
@property (nonatomic, readonly) double yMin;
- (double)getYMin;
- (double)getYMin:(enum AxisDependency)axis;

/// \returns  the greatest y-value the data object contains.
@property (nonatomic, readonly) double yMax;
- (double)getYMax;
- (double)getYMax:(enum AxisDependency)axis;

/// \returns  the average length (in characters) across all values in the x-vals array
@property (nonatomic, readonly) double xValAverageLength;

/// \returns  the total number of y-values across all DataSet objects the this object represents.
@property (nonatomic, readonly) NSInteger yValCount;

/// Adds a new x-value to the chart data.
- (void)addXValue:(NSString * _Nullable)xVal;

/// Removes the x-value at the specified index.
- (void)removeXValue:(NSInteger)index;

/// \returns  the array of ChartDataSets this object holds.
@property (nonatomic, copy) NSArray<id <IChartDataSet>> * _Nonnull dataSets;

/// \returns  the total number of x-values this ChartData object represents (the size of the x-values array)
@property (nonatomic, readonly) NSInteger xValCount;

/// Get the Entry for a corresponding highlight object
///
/// \param highlight 
///
/// \returns  the entry that is highlighted
- (ChartDataEntry * _Nullable)getEntryForHighlight:(ChartHighlight * _Nonnull)highlight;

/// IMPORTANT: This method does calculations at runtime. Use with care in performance critical situations.
///
/// \param label 
///
/// \param ignorecase 
///
/// \returns  the DataSet Object with the given label. Sensitive or not.
- (id <IChartDataSet> _Nullable)getDataSetByLabel:(NSString * _Nonnull)label ignorecase:(BOOL)ignorecase;
- (id <IChartDataSet> _Null_unspecified)getDataSetByIndex:(NSInteger)index;
- (void)addDataSet:(id <IChartDataSet> _Null_unspecified)d;
- (void)handleEmptyAxis:(id <IChartDataSet> _Nullable)firstLeft firstRight:(id <IChartDataSet> _Nullable)firstRight;

/// Removes the given DataSet from this data object. Also recalculates all minimum and maximum values.
///
/// \returns  true if a DataSet was removed, false if no DataSet could be removed.
- (BOOL)removeDataSet:(id <IChartDataSet> _Null_unspecified)dataSet;

/// Removes the DataSet at the given index in the DataSet array from the data object. Also recalculates all minimum and maximum values.
///
/// \returns  true if a DataSet was removed, false if no DataSet could be removed.
- (BOOL)removeDataSetByIndex:(NSInteger)index;

/// Adds an Entry to the DataSet at the specified index. Entries are added to the end of the list.
- (void)addEntry:(ChartDataEntry * _Nonnull)e dataSetIndex:(NSInteger)dataSetIndex;

/// Removes the given Entry object from the DataSet at the specified index.
- (BOOL)removeEntry:(ChartDataEntry * _Null_unspecified)entry dataSetIndex:(NSInteger)dataSetIndex;

/// Removes the Entry object at the given xIndex from the ChartDataSet at the specified index.
///
/// \returns  true if an entry was removed, false if no Entry was found that meets the specified requirements.
- (BOOL)removeEntryByXIndex:(NSInteger)xIndex dataSetIndex:(NSInteger)dataSetIndex;

/// \returns  the DataSet that contains the provided Entry, or null, if no DataSet contains this entry.
- (id <IChartDataSet> _Nullable)getDataSetForEntry:(ChartDataEntry * _Null_unspecified)e;

/// \returns  the index of the provided DataSet inside the DataSets array of this data object. -1 if the DataSet was not found.
- (NSInteger)indexOfDataSet:(id <IChartDataSet> _Nonnull)dataSet;

/// \returns  the first DataSet from the datasets-array that has it's dependency on the left axis. Returns null if no DataSet with left dependency could be found.
- (id <IChartDataSet> _Nullable)getFirstLeft;

/// \returns  the first DataSet from the datasets-array that has it's dependency on the right axis. Returns null if no DataSet with right dependency could be found.
- (id <IChartDataSet> _Nullable)getFirstRight;

/// \returns  all colors used across all DataSet objects this object represents.
- (NSArray<UIColor *> * _Nullable)getColors;

/// Generates an x-values array filled with numbers in range specified by the parameters. Can be used for convenience.
- (NSArray<NSString *> * _Nonnull)generateXVals:(NSInteger)from to:(NSInteger)to;

/// Sets a custom ValueFormatter for all DataSets this data object contains.
- (void)setValueFormatter:(NSNumberFormatter * _Null_unspecified)formatter;

/// Sets the color of the value-text (color in which the value-labels are drawn) for all DataSets this data object contains.
- (void)setValueTextColor:(UIColor * _Null_unspecified)color;

/// Sets the font for all value-labels for all DataSets this data object contains.
- (void)setValueFont:(UIFont * _Null_unspecified)font;

/// Enables / disables drawing values (value-text) for all DataSets this data object contains.
- (void)setDrawValues:(BOOL)enabled;

/// Enables / disables highlighting values for all DataSets this data object contains. If set to true, this means that values can be highlighted programmatically or by touch gesture.
@property (nonatomic) BOOL highlightEnabled;

/// if true, value highlightning is enabled
@property (nonatomic, readonly) BOOL isHighlightEnabled;

/// Clears this data object from all DataSets and removes all Entries. Don't forget to invalidate the chart after this.
- (void)clearValues;

/// Checks if this data object contains the specified Entry.
///
/// \returns  true if so, false if not.
- (BOOL)containsWithEntry:(ChartDataEntry * _Nonnull)entry;

/// Checks if this data object contains the specified DataSet.
///
/// \returns  true if so, false if not.
- (BOOL)containsWithDataSet:(id <IChartDataSet> _Nonnull)dataSet;

/// MARK: - ObjC compatibility
///
/// \returns  the average length (in characters) across all values in the x-vals array
@property (nonatomic, copy) NSArray<NSObject *> * _Nonnull xValsObjc;
@end


SWIFT_CLASS("_TtC6Charts35BarLineScatterCandleBubbleChartData")
@interface BarLineScatterCandleBubbleChartData : ChartData
- (nonnull instancetype)init OBJC_DESIGNATED_INITIALIZER;
- (nonnull instancetype)initWithXVals:(NSArray<NSObject *> * _Nullable)xVals dataSets:(NSArray<id <IChartDataSet>> * _Nullable)dataSets OBJC_DESIGNATED_INITIALIZER;
@end


SWIFT_CLASS("_TtC6Charts12BarChartData")
@interface BarChartData : BarLineScatterCandleBubbleChartData
- (nonnull instancetype)init OBJC_DESIGNATED_INITIALIZER;
- (nonnull instancetype)initWithXVals:(NSArray<NSObject *> * _Nullable)xVals dataSets:(NSArray<id <IChartDataSet>> * _Nullable)dataSets OBJC_DESIGNATED_INITIALIZER;

/// The spacing is relative to a full bar width
@property (nonatomic) CGFloat groupSpace;

/// \returns  true if this BarData object contains grouped DataSets (more than 1 DataSet).
@property (nonatomic, readonly) BOOL isGrouped;
@end


SWIFT_CLASS("_TtC6Charts14ChartDataEntry")
@interface ChartDataEntry : NSObject

/// the actual value (y axis)
@property (nonatomic) double value;

/// the index on the x-axis
@property (nonatomic) NSInteger xIndex;

/// optional spot for additional data this Entry represents
@property (nonatomic, strong) id _Nullable data;
- (nonnull instancetype)init OBJC_DESIGNATED_INITIALIZER;
- (nonnull instancetype)initWithValue:(double)value xIndex:(NSInteger)xIndex OBJC_DESIGNATED_INITIALIZER;
- (nonnull instancetype)initWithValue:(double)value xIndex:(NSInteger)xIndex data:(id _Nullable)data OBJC_DESIGNATED_INITIALIZER;
- (BOOL)isEqual:(id _Nullable)object;
@property (nonatomic, readonly, copy) NSString * _Nonnull description;
- (id _Nonnull)copyWithZone:(struct _NSZone * _Null_unspecified)zone;
@end


SWIFT_CLASS("_TtC6Charts17BarChartDataEntry")
@interface BarChartDataEntry : ChartDataEntry
- (nonnull instancetype)init OBJC_DESIGNATED_INITIALIZER;

/// Constructor for stacked bar entries.
- (nonnull instancetype)initWithValues:(NSArray<NSNumber *> * _Nonnull)values xIndex:(NSInteger)xIndex OBJC_DESIGNATED_INITIALIZER;

/// Constructor for normal bars (not stacked).
- (nonnull instancetype)initWithValue:(double)value xIndex:(NSInteger)xIndex OBJC_DESIGNATED_INITIALIZER;

/// Constructor for stacked bar entries.
- (nonnull instancetype)initWithValues:(NSArray<NSNumber *> * _Nonnull)values xIndex:(NSInteger)xIndex label:(NSString * _Nonnull)label OBJC_DESIGNATED_INITIALIZER;

/// Constructor for normal bars (not stacked).
- (nonnull instancetype)initWithValue:(double)value xIndex:(NSInteger)xIndex data:(id _Nullable)data OBJC_DESIGNATED_INITIALIZER;
- (double)getBelowSum:(NSInteger)stackIndex;

/// \returns  the sum of all negative values this entry (if stacked) contains. (this is a positive number)
@property (nonatomic, readonly) double negativeSum;

/// \returns  the sum of all positive values this entry (if stacked) contains.
@property (nonatomic, readonly) double positiveSum;
- (void)calcPosNegSum;

/// the values the stacked barchart holds
@property (nonatomic, readonly) BOOL isStacked;

/// the values the stacked barchart holds
@property (nonatomic, copy) NSArray<NSNumber *> * _Nullable values;
- (id _Nonnull)copyWithZone:(struct _NSZone * _Null_unspecified)zone;
@end


SWIFT_PROTOCOL("_TtP6Charts17ChartDataProvider_")
@protocol ChartDataProvider

/// \returns  the minimum x-value of the chart, regardless of zoom or translation.
@property (nonatomic, readonly) double chartXMin;

/// \returns  the maximum x-value of the chart, regardless of zoom or translation.
@property (nonatomic, readonly) double chartXMax;

/// \returns  the minimum y-value of the chart, regardless of zoom or translation.
@property (nonatomic, readonly) double chartYMin;

/// \returns  the maximum y-value of the chart, regardless of zoom or translation.
@property (nonatomic, readonly) double chartYMax;
@property (nonatomic, readonly) NSInteger xValCount;
@property (nonatomic, readonly) CGPoint centerOffsets;
@property (nonatomic, readonly, strong) ChartData * _Nullable data;
@end

@class ChartTransformer;

SWIFT_PROTOCOL("_TtP6Charts43BarLineScatterCandleBubbleChartDataProvider_")
@protocol BarLineScatterCandleBubbleChartDataProvider <ChartDataProvider>
- (ChartTransformer * _Nonnull)getTransformer:(enum AxisDependency)which;
@property (nonatomic, readonly) NSInteger maxVisibleValueCount;
- (BOOL)isInverted:(enum AxisDependency)axis;
@property (nonatomic, readonly) NSInteger lowestVisibleXIndex;
@property (nonatomic, readonly) NSInteger highestVisibleXIndex;
@end


SWIFT_PROTOCOL("_TtP6Charts20BarChartDataProvider_")
@protocol BarChartDataProvider <BarLineScatterCandleBubbleChartDataProvider>
@property (nonatomic, readonly, strong) BarChartData * _Nullable barData;
@property (nonatomic, readonly) BOOL isDrawBarShadowEnabled;
@property (nonatomic, readonly) BOOL isDrawValueAboveBarEnabled;
@property (nonatomic, readonly) BOOL isDrawHighlightArrowEnabled;
@end

enum ChartDataSetRounding : NSInteger;

SWIFT_PROTOCOL("_TtP6Charts13IChartDataSet_")
@protocol IChartDataSet

/// Use this method to tell the data set that the underlying data has changed
- (void)notifyDataSetChanged;

/// This is an opportunity to calculate the minimum and maximum y value in the specified range. If your data is in an array, you might loop over them to find the values. If your data is in a database, you might query for the min/max and put them in variables.
///
/// \param start the index of the first y entry to calculate
///
/// \param end the index of the last y entry to calculate
- (void)calcMinMaxWithStart:(NSInteger)start end:(NSInteger)end;

/// \returns  the minimum y-value this DataSet holds
@property (nonatomic, readonly) double yMin;

/// \returns  the maximum y-value this DataSet holds
@property (nonatomic, readonly) double yMax;

/// \returns  the number of y-values this DataSet represents
@property (nonatomic, readonly) NSInteger entryCount;

/// \returns  the value of the Entry object at the given xIndex. Returns NaN if no value is at the given x-index.
- (double)yValForXIndex:(NSInteger)x;

/// \returns  all of the y values of the Entry objects at the given xIndex. Returns NaN if no value is at the given x-index.
- (NSArray<NSNumber *> * _Nonnull)yValsForXIndex:(NSInteger)x;

/// \param error out of bounds
/// if <code>i
/// </code> is out of bounds, it may throw an out-of-bounds exception
///
/// \returns  the entry object found at the given index (not x-index!)
- (ChartDataEntry * _Nullable)entryForIndex:(NSInteger)i;

/// \returns  the first Entry object found at the given xIndex with binary search.
/// If the no Entry at the specifed x-index is found, this method returns the Entry at the closest x-index.
/// nil if no Entry object at that index.
- (ChartDataEntry * _Nullable)entryForXIndex:(NSInteger)x rounding:(enum ChartDataSetRounding)rounding;

/// \returns  the first Entry object found at the given xIndex with binary search.
/// If the no Entry at the specifed x-index is found, this method returns the Entry at the closest x-index.
/// nil if no Entry object at that index.
- (ChartDataEntry * _Nullable)entryForXIndex:(NSInteger)x;

/// \returns  all Entry objects found at the given xIndex with binary search.
/// An empty array if no Entry object at that index.
- (NSArray<ChartDataEntry *> * _Nonnull)entriesForXIndex:(NSInteger)x;

/// \param x x-index of the entry to search for
///
/// \param rounding x-index of the entry to search for
///
/// \returns  the array-index of the specified entry
- (NSInteger)entryIndexWithXIndex:(NSInteger)x rounding:(enum ChartDataSetRounding)rounding;

/// \param e the entry to search for
///
/// \returns  the array-index of the specified entry
- (NSInteger)entryIndexWithEntry:(ChartDataEntry * _Nonnull)e;

/// Adds an Entry to the DataSet dynamically.
///
/// <em>optional feature, can return false if not implemented</em>
///
/// Entries are added to the end of the list.
///
/// \param e the entry to add
///
/// \returns  true if the entry was added successfully, false if this feature is not supported
- (BOOL)addEntry:(ChartDataEntry * _Nonnull)e;

/// Adds an Entry to the DataSet dynamically. Entries are added to their appropriate index respective to it's x-index. This will also recalculate the current minimum and maximum values of the DataSet and the value-sum.
///
/// <em>optional feature, can return false if not implemented</em>
///
/// Entries are added to the end of the list.
///
/// \param e the entry to add
///
/// \returns  true if the entry was added successfully, false if this feature is not supported
- (BOOL)addEntryOrdered:(ChartDataEntry * _Nonnull)e;

/// Removes an Entry from the DataSet dynamically.
///
/// <em>optional feature, can return false if not implemented</em>
///
/// \param entry the entry to remove
///
/// \returns  true if the entry was removed successfully, false if the entry does not exist or if this feature is not supported
- (BOOL)removeEntry:(ChartDataEntry * _Nonnull)entry;

/// Removes the Entry object that has the given xIndex from the DataSet.
///
/// <em>optional feature, can return false if not implemented</em>
///
/// \param xIndex the xIndex to remove
///
/// \returns  true if the entry was removed successfully, false if the entry does not exist or if this feature is not supported
- (BOOL)removeEntryWithXIndex:(NSInteger)xIndex;

/// Removes the first Entry (at index 0) of this DataSet from the entries array.
///
/// <em>optional feature, can return false if not implemented</em>
///
/// \returns  true if the entry was removed successfully, false if the entry does not exist or if this feature is not supported
- (BOOL)removeFirst;

/// Removes the last Entry (at index 0) of this DataSet from the entries array.
///
/// <em>optional feature, can return false if not implemented</em>
///
/// \returns  true if the entry was removed successfully, false if the entry does not exist or if this feature is not supported
- (BOOL)removeLast;

/// Checks if this DataSet contains the specified Entry.
///
/// \returns  true if contains the entry, false if not.
- (BOOL)contains:(ChartDataEntry * _Nonnull)e;

/// Removes all values from this DataSet and does all necessary recalculations.
///
/// <em>optional feature, could throw if not implemented</em>
- (void)clear;

/// The label string that describes the DataSet.
@property (nonatomic, readonly, copy) NSString * _Nullable label;

/// The axis this DataSet should be plotted against.
@property (nonatomic, readonly) enum AxisDependency axisDependency;

/// List representing all colors that are used for drawing the actual values for this DataSet
@property (nonatomic, readonly, copy) NSArray<UIColor *> * _Nonnull valueColors;

/// All the colors that are used for this DataSet. Colors are reused as soon as the number of Entries the DataSet represents is higher than the size of the colors array.
@property (nonatomic, readonly, copy) NSArray<UIColor *> * _Nonnull colors;

/// \returns  the color at the given index of the DataSet's color array.
/// This prevents out-of-bounds by performing a modulus on the color index, so colours will repeat themselves.
- (UIColor * _Nonnull)colorAt:(NSInteger)index;
- (void)resetColors;
- (void)addColor:(UIColor * _Nonnull)color;
- (void)setColor:(UIColor * _Nonnull)color;

/// if true, value highlighting is enabled
@property (nonatomic) BOOL highlightEnabled;

/// \returns  true if value highlighting is enabled for this dataset
@property (nonatomic, readonly) BOOL isHighlightEnabled;

/// The formatter used to customly format the values
@property (nonatomic, strong) NSNumberFormatter * _Nullable valueFormatter;

/// Sets/get a single color for value text. Setting the color clears the colors array and adds a single color. Getting will return the first color in the array.
@property (nonatomic, strong) UIColor * _Nonnull valueTextColor;

/// \returns  the color at the specified index that is used for drawing the values inside the chart. Uses modulus internally.
- (UIColor * _Nonnull)valueTextColorAt:(NSInteger)index;

/// the font for the value-text labels
@property (nonatomic, strong) UIFont * _Nonnull valueFont;

/// Set this to true to draw y-values on the chart
@property (nonatomic) BOOL drawValuesEnabled;

/// Returns true if y-value drawing is enabled, false if not
@property (nonatomic, readonly) BOOL isDrawValuesEnabled;

/// Set the visibility of this DataSet. If not visible, the DataSet will not be drawn to the chart upon refreshing it.
@property (nonatomic) BOOL visible;

/// Returns true if this DataSet is visible inside the chart, or false if it is currently hidden.
@property (nonatomic, readonly) BOOL isVisible;
@end


SWIFT_PROTOCOL("_TtP6Charts39IBarLineScatterCandleBubbleChartDataSet_")
@protocol IBarLineScatterCandleBubbleChartDataSet <IChartDataSet>
@property (nonatomic, strong) UIColor * _Nonnull highlightColor;
@property (nonatomic) CGFloat highlightLineWidth;
@property (nonatomic) CGFloat highlightLineDashPhase;
@property (nonatomic, copy) NSArray<NSNumber *> * _Nullable highlightLineDashLengths;
@end


SWIFT_PROTOCOL("_TtP6Charts16IBarChartDataSet_")
@protocol IBarChartDataSet <IBarLineScatterCandleBubbleChartDataSet>

/// space indicator between the bars in percentage of the whole width of one value (0.15 == 15% of bar width)
@property (nonatomic) CGFloat barSpace;

/// \returns  true if this DataSet is stacked (stacksize > 1) or not.
@property (nonatomic, readonly) BOOL isStacked;

/// \returns  the maximum number of bars that can be stacked upon another in this DataSet.
@property (nonatomic, readonly) NSInteger stackSize;

/// the color used for drawing the bar-shadows. The bar shadows is a surface behind the bar that indicates the maximum value
@property (nonatomic, strong) UIColor * _Nonnull barShadowColor;

/// the width used for drawing borders around the bars. If borderWidth == 0, no border will be drawn.
@property (nonatomic) CGFloat barBorderWidth;

/// the color drawing borders around the bars.
@property (nonatomic, strong) UIColor * _Nonnull barBorderColor;

/// the alpha value (transparency) that is used for drawing the highlight indicator bar. min = 0.0 (fully transparent), max = 1.0 (fully opaque)
@property (nonatomic) CGFloat highlightAlpha;

/// array of labels used to describe the different values of the stacked bars
@property (nonatomic, copy) NSArray<NSString *> * _Nonnull stackLabels;
@end


SWIFT_CLASS("_TtC6Charts16ChartBaseDataSet")
@interface ChartBaseDataSet : NSObject <IChartDataSet>
- (nonnull instancetype)init OBJC_DESIGNATED_INITIALIZER;
- (nonnull instancetype)initWithLabel:(NSString * _Nullable)label OBJC_DESIGNATED_INITIALIZER;

/// Use this method to tell the data set that the underlying data has changed
- (void)notifyDataSetChanged;
- (void)calcMinMaxWithStart:(NSInteger)start end:(NSInteger)end;
@property (nonatomic, readonly) double yMin;
@property (nonatomic, readonly) double yMax;
@property (nonatomic, readonly) NSInteger entryCount;
- (double)yValForXIndex:(NSInteger)x;
- (NSArray<NSNumber *> * _Nonnull)yValsForXIndex:(NSInteger)x;
- (ChartDataEntry * _Nullable)entryForIndex:(NSInteger)i;
- (ChartDataEntry * _Nullable)entryForXIndex:(NSInteger)x rounding:(enum ChartDataSetRounding)rounding;
- (ChartDataEntry * _Nullable)entryForXIndex:(NSInteger)x;
- (NSArray<ChartDataEntry *> * _Nonnull)entriesForXIndex:(NSInteger)x;
- (NSInteger)entryIndexWithXIndex:(NSInteger)x rounding:(enum ChartDataSetRounding)rounding;
- (NSInteger)entryIndexWithEntry:(ChartDataEntry * _Nonnull)e;
- (BOOL)addEntry:(ChartDataEntry * _Nonnull)e;
- (BOOL)addEntryOrdered:(ChartDataEntry * _Nonnull)e;
- (BOOL)removeEntry:(ChartDataEntry * _Nonnull)entry;
- (BOOL)removeEntryWithXIndex:(NSInteger)xIndex;
- (BOOL)removeFirst;
- (BOOL)removeLast;
- (BOOL)contains:(ChartDataEntry * _Nonnull)e;
- (void)clear;

/// All the colors that are used for this DataSet. Colors are reused as soon as the number of Entries the DataSet represents is higher than the size of the colors array.
@property (nonatomic, copy) NSArray<UIColor *> * _Nonnull colors;

/// List representing all colors that are used for drawing the actual values for this DataSet
@property (nonatomic, copy) NSArray<UIColor *> * _Nonnull valueColors;

/// The label string that describes the DataSet.
@property (nonatomic, copy) NSString * _Nullable label;

/// The axis this DataSet should be plotted against.
@property (nonatomic) enum AxisDependency axisDependency;

/// \returns  the color at the given index of the DataSet's color array.
/// This prevents out-of-bounds by performing a modulus on the color index, so colours will repeat themselves.
- (UIColor * _Nonnull)colorAt:(NSInteger)index;

/// Resets all colors of this DataSet and recreates the colors array.
- (void)resetColors;

/// Adds a new color to the colors array of the DataSet.
///
/// \param color the color to add
- (void)addColor:(UIColor * _Nonnull)color;

/// Sets the one and only color that should be used for this DataSet. Internally, this recreates the colors array and adds the specified color.
///
/// \param color the color to set
- (void)setColor:(UIColor * _Nonnull)color;

/// Sets colors to a single color a specific alpha value.
///
/// \param color the color to set
///
/// \param alpha alpha to apply to the set <code>color
/// </code>
- (void)setColor:(UIColor * _Nonnull)color alpha:(CGFloat)alpha;

/// Sets colors with a specific alpha value.
///
/// \param colors the colors to set
///
/// \param alpha alpha to apply to the set <code>colors
/// </code>
- (void)setColors:(NSArray<UIColor *> * _Nonnull)colors alpha:(CGFloat)alpha;

/// if true, value highlighting is enabled
@property (nonatomic) BOOL highlightEnabled;

/// \returns  true if value highlighting is enabled for this dataset
@property (nonatomic, readonly) BOOL isHighlightEnabled;

/// The formatter used to customly format the values
@property (nonatomic, strong) NSNumberFormatter * _Nullable valueFormatter;

/// Sets/get a single color for value text. Setting the color clears the colors array and adds a single color. Getting will return the first color in the array.
@property (nonatomic, strong) UIColor * _Nonnull valueTextColor;

/// \returns  the color at the specified index that is used for drawing the values inside the chart. Uses modulus internally.
- (UIColor * _Nonnull)valueTextColorAt:(NSInteger)index;

/// the font for the value-text labels
@property (nonatomic, strong) UIFont * _Nonnull valueFont;

/// Set this to true to draw y-values on the chart
@property (nonatomic) BOOL drawValuesEnabled;

/// Returns true if y-value drawing is enabled, false if not
@property (nonatomic, readonly) BOOL isDrawValuesEnabled;

/// Set the visibility of this DataSet. If not visible, the DataSet will not be drawn to the chart upon refreshing it.
@property (nonatomic) BOOL visible;

/// Returns true if this DataSet is visible inside the chart, or false if it is currently hidden.
@property (nonatomic, readonly) BOOL isVisible;
@property (nonatomic, readonly, copy) NSString * _Nonnull description;
@property (nonatomic, readonly, copy) NSString * _Nonnull debugDescription;
- (id _Nonnull)copyWithZone:(struct _NSZone * _Null_unspecified)zone;
@end


SWIFT_CLASS("_TtC6Charts12ChartDataSet")
@interface ChartDataSet : ChartBaseDataSet
- (nonnull instancetype)init OBJC_DESIGNATED_INITIALIZER;
- (nonnull instancetype)initWithLabel:(NSString * _Nullable)label OBJC_DESIGNATED_INITIALIZER;
- (nonnull instancetype)initWithYVals:(NSArray<ChartDataEntry *> * _Nullable)yVals label:(NSString * _Nullable)label OBJC_DESIGNATED_INITIALIZER;
- (nonnull instancetype)initWithYVals:(NSArray<ChartDataEntry *> * _Nullable)yVals;

/// the array of y-values that this DataSet represents.
@property (nonatomic, copy) NSArray<ChartDataEntry *> * _Nonnull yVals;

/// Use this method to tell the data set that the underlying data has changed
- (void)notifyDataSetChanged;
- (void)calcMinMaxWithStart:(NSInteger)start end:(NSInteger)end;

/// \returns  the minimum y-value this DataSet holds
@property (nonatomic, readonly) double yMin;

/// \returns  the maximum y-value this DataSet holds
@property (nonatomic, readonly) double yMax;

/// \returns  the number of y-values this DataSet represents
@property (nonatomic, readonly) NSInteger entryCount;

/// \returns  the value of the Entry object at the given xIndex. Returns NaN if no value is at the given x-index.
- (double)yValForXIndex:(NSInteger)x;

/// \returns  all of the y values of the Entry objects at the given xIndex. Returns NaN if no value is at the given x-index.
- (NSArray<NSNumber *> * _Nonnull)yValsForXIndex:(NSInteger)x;

/// \param error out of bounds
/// if <code>i
/// </code> is out of bounds, it may throw an out-of-bounds exception
///
/// \returns  the entry object found at the given index (not x-index!)
- (ChartDataEntry * _Nullable)entryForIndex:(NSInteger)i;

/// \returns  the first Entry object found at the given xIndex with binary search.
/// If the no Entry at the specifed x-index is found, this method returns the Entry at the closest x-index.
/// nil if no Entry object at that index.
- (ChartDataEntry * _Nullable)entryForXIndex:(NSInteger)x rounding:(enum ChartDataSetRounding)rounding;

/// \returns  the first Entry object found at the given xIndex with binary search.
/// If the no Entry at the specifed x-index is found, this method returns the Entry at the closest x-index.
/// nil if no Entry object at that index.
- (ChartDataEntry * _Nullable)entryForXIndex:(NSInteger)x;

/// \returns  all Entry objects found at the given xIndex with binary search.
/// An empty array if no Entry object at that index.
- (NSArray<ChartDataEntry *> * _Nonnull)entriesForXIndex:(NSInteger)x;

/// \param x x-index of the entry to search for
///
/// \param rounding x-index of the entry to search for
///
/// \returns  the array-index of the specified entry
- (NSInteger)entryIndexWithXIndex:(NSInteger)x rounding:(enum ChartDataSetRounding)rounding;

/// \param e the entry to search for
///
/// \returns  the array-index of the specified entry
- (NSInteger)entryIndexWithEntry:(ChartDataEntry * _Nonnull)e;

/// Adds an Entry to the DataSet dynamically. Entries are added to the end of the list. This will also recalculate the current minimum and maximum values of the DataSet and the value-sum.
///
/// \param e the entry to add
///
/// \returns  true
- (BOOL)addEntry:(ChartDataEntry * _Nonnull)e;

/// Adds an Entry to the DataSet dynamically. Entries are added to their appropriate index respective to it's x-index. This will also recalculate the current minimum and maximum values of the DataSet and the value-sum.
///
/// \param e the entry to add
///
/// \returns  true
- (BOOL)addEntryOrdered:(ChartDataEntry * _Nonnull)e;

/// Removes an Entry from the DataSet dynamically. This will also recalculate the current minimum and maximum values of the DataSet and the value-sum.
///
/// \param entry the entry to remove
///
/// \returns  true if the entry was removed successfully, else if the entry does not exist
- (BOOL)removeEntry:(ChartDataEntry * _Nonnull)entry;

/// Removes the first Entry (at index 0) of this DataSet from the entries array.
///
/// \returns  true if successful, false if not.
- (BOOL)removeFirst;

/// Removes the last Entry (at index size-1) of this DataSet from the entries array.
///
/// \returns  true if successful, false if not.
- (BOOL)removeLast;

/// Checks if this DataSet contains the specified Entry.
///
/// \returns  true if contains the entry, false if not.
- (BOOL)contains:(ChartDataEntry * _Nonnull)e;

/// Removes all values from this DataSet and recalculates min and max value.
- (void)clear;

/// \returns  the number of entries this DataSet holds.
@property (nonatomic, readonly) NSInteger valueCount;
- (id _Nonnull)copyWithZone:(struct _NSZone * _Null_unspecified)zone;
@end


SWIFT_CLASS("_TtC6Charts38BarLineScatterCandleBubbleChartDataSet")
@interface BarLineScatterCandleBubbleChartDataSet : ChartDataSet <IBarLineScatterCandleBubbleChartDataSet>
@property (nonatomic, strong) UIColor * _Nonnull highlightColor;
@property (nonatomic) CGFloat highlightLineWidth;
@property (nonatomic) CGFloat highlightLineDashPhase;
@property (nonatomic, copy) NSArray<NSNumber *> * _Nullable highlightLineDashLengths;
- (id _Nonnull)copyWithZone:(struct _NSZone * _Null_unspecified)zone;
- (nonnull instancetype)init OBJC_DESIGNATED_INITIALIZER;
- (nonnull instancetype)initWithLabel:(NSString * _Nullable)label OBJC_DESIGNATED_INITIALIZER;
- (nonnull instancetype)initWithYVals:(NSArray<ChartDataEntry *> * _Nullable)yVals label:(NSString * _Nullable)label OBJC_DESIGNATED_INITIALIZER;
@end


SWIFT_CLASS("_TtC6Charts15BarChartDataSet")
@interface BarChartDataSet : BarLineScatterCandleBubbleChartDataSet <IBarChartDataSet>
- (nonnull instancetype)init OBJC_DESIGNATED_INITIALIZER;
- (nonnull instancetype)initWithYVals:(NSArray<ChartDataEntry *> * _Nullable)yVals label:(NSString * _Nullable)label OBJC_DESIGNATED_INITIALIZER;
- (void)calcMinMaxWithStart:(NSInteger)start end:(NSInteger)end;

/// \returns  the maximum number of bars that can be stacked upon another in this DataSet.
@property (nonatomic, readonly) NSInteger stackSize;

/// \returns  true if this DataSet is stacked (stacksize > 1) or not.
@property (nonatomic, readonly) BOOL isStacked;

/// \returns  the overall entry count, including counting each stack-value individually
@property (nonatomic, readonly) NSInteger entryCountStacks;

/// array of labels used to describe the different values of the stacked bars
@property (nonatomic, copy) NSArray<NSString *> * _Nonnull stackLabels;

/// space indicator between the bars in percentage of the whole width of one value (0.15 == 15% of bar width)
@property (nonatomic) CGFloat barSpace;

/// the color used for drawing the bar-shadows. The bar shadows is a surface behind the bar that indicates the maximum value
@property (nonatomic, strong) UIColor * _Nonnull barShadowColor;

/// the width used for drawing borders around the bars. If borderWidth == 0, no border will be drawn.
@property (nonatomic) CGFloat barBorderWidth;

/// the color drawing borders around the bars.
@property (nonatomic, strong) UIColor * _Nonnull barBorderColor;

/// the alpha value (transparency) that is used for drawing the highlight indicator bar. min = 0.0 (fully transparent), max = 1.0 (fully opaque)
@property (nonatomic) CGFloat highlightAlpha;
- (id _Nonnull)copyWithZone:(struct _NSZone * _Null_unspecified)zone;
@end

@class BarLineChartViewBase;

SWIFT_CLASS("_TtC6Charts16ChartHighlighter")
@interface ChartHighlighter : NSObject

/// instance of the data-provider
@property (nonatomic, weak) BarLineChartViewBase * _Nullable chart;
- (nonnull instancetype)initWithChart:(BarLineChartViewBase * _Nonnull)chart OBJC_DESIGNATED_INITIALIZER;

/// Returns a Highlight object corresponding to the given x- and y- touch positions in pixels.
///
/// \param x 
///
/// \param y 
///
/// \returns  
- (ChartHighlight * _Nullable)getHighlightWithX:(CGFloat)x y:(CGFloat)y;

/// Returns the corresponding x-index for a given touch-position in pixels.
///
/// \param x 
///
/// \returns  
- (NSInteger)getXIndex:(CGFloat)x;
@end

@class ChartSelectionDetail;
@class ChartRange;

SWIFT_CLASS("_TtC6Charts19BarChartHighlighter")
@interface BarChartHighlighter : ChartHighlighter
- (ChartHighlight * _Nullable)getHighlightWithX:(CGFloat)x y:(CGFloat)y;
- (NSInteger)getXIndex:(CGFloat)x;

/// This method creates the Highlight object that also indicates which value of a stacked BarEntry has been selected.
///
/// \param selectionDetail the selection detail to work with
///
/// \param set 
///
/// \param xIndex 
///
/// \param yValue 
///
/// \returns  
- (ChartHighlight * _Nullable)getStackedHighlightWithSelectionDetail:(ChartSelectionDetail * _Nonnull)selectionDetail set:(id <IBarChartDataSet> _Nonnull)set xIndex:(NSInteger)xIndex yValue:(double)yValue;

/// Returns the index of the closest value inside the values array / ranges (stacked barchart) to the value given as a parameter.
///
/// \param entry 
///
/// \param value 
///
/// \returns  
- (NSInteger)getClosestStackIndexWithRanges:(NSArray<ChartRange *> * _Nullable)ranges value:(double)value;

/// Returns the base x-value to the corresponding x-touch value in pixels.
///
/// \param x 
///
/// \returns  
- (double)getBase:(CGFloat)x;

/// Splits up the stack-values of the given bar-entry into Range objects.
///
/// \param entry 
///
/// \returns  
- (NSArray<ChartRange *> * _Nullable)getRangesWithEntry:(BarChartDataEntry * _Nonnull)entry;
- (nonnull instancetype)initWithChart:(BarLineChartViewBase * _Nonnull)chart OBJC_DESIGNATED_INITIALIZER;
@end

@class ChartViewPortHandler;

SWIFT_CLASS("_TtC6Charts17ChartRendererBase")
@interface ChartRendererBase : NSObject

/// the component that handles the drawing area of the chart and it's offsets
@property (nonatomic, strong) ChartViewPortHandler * _Null_unspecified viewPortHandler;

/// the minimum value on the x-axis that should be plotted
@property (nonatomic) NSInteger minX;

/// the maximum value on the x-axis that should be plotted
@property (nonatomic) NSInteger maxX;
- (nonnull instancetype)init OBJC_DESIGNATED_INITIALIZER;
- (nonnull instancetype)initWithViewPortHandler:(ChartViewPortHandler * _Nonnull)viewPortHandler OBJC_DESIGNATED_INITIALIZER;

/// Calculates the minimum and maximum x-value the chart can currently display (with the given zoom level).
- (void)calcXBoundsWithChart:(id <BarLineScatterCandleBubbleChartDataProvider> _Nonnull)chart xAxisModulus:(NSInteger)xAxisModulus;
@end

@class ChartAnimator;

SWIFT_CLASS("_TtC6Charts21ChartDataRendererBase")
@interface ChartDataRendererBase : ChartRendererBase
@property (nonatomic, strong) ChartAnimator * _Nullable animator;
- (nonnull instancetype)initWithAnimator:(ChartAnimator * _Nullable)animator viewPortHandler:(ChartViewPortHandler * _Nonnull)viewPortHandler OBJC_DESIGNATED_INITIALIZER;
- (void)drawDataWithContext:(CGContextRef _Nonnull)context;
- (void)drawValuesWithContext:(CGContextRef _Nonnull)context;
- (void)drawExtrasWithContext:(CGContextRef _Nonnull)context;

/// Draws all highlight indicators for the values that are currently highlighted.
///
/// \param indices the highlighted values
- (void)drawHighlightedWithContext:(CGContextRef _Nonnull)context indices:(NSArray<ChartHighlight *> * _Nonnull)indices;
@end


SWIFT_CLASS("_TtC6Charts16BarChartRenderer")
@interface BarChartRenderer : ChartDataRendererBase
@property (nonatomic, weak) id <BarChartDataProvider> _Nullable dataProvider;
- (nonnull instancetype)initWithDataProvider:(id <BarChartDataProvider> _Nullable)dataProvider animator:(ChartAnimator * _Nullable)animator viewPortHandler:(ChartViewPortHandler * _Nonnull)viewPortHandler OBJC_DESIGNATED_INITIALIZER;
- (void)drawDataWithContext:(CGContextRef _Nonnull)context;
- (void)drawDataSetWithContext:(CGContextRef _Nonnull)context dataSet:(id <IBarChartDataSet> _Nonnull)dataSet index:(NSInteger)index;
- (void)drawValuesWithContext:(CGContextRef _Nonnull)context;

/// Draws a value at the specified x and y position.
- (void)drawValueWithContext:(CGContextRef _Nonnull)context value:(NSString * _Nonnull)value xPos:(CGFloat)xPos yPos:(CGFloat)yPos font:(UIFont * _Nonnull)font align:(NSTextAlignment)align color:(UIColor * _Nonnull)color;
- (void)drawExtrasWithContext:(CGContextRef _Nonnull)context;
- (void)drawHighlightedWithContext:(CGContextRef _Nonnull)context indices:(NSArray<ChartHighlight *> * _Nonnull)indices;
@end


SWIFT_PROTOCOL("_TtP6Charts21ChartAnimatorDelegate_")
@protocol ChartAnimatorDelegate

/// Called when the Animator has stepped.
- (void)chartAnimatorUpdated:(ChartAnimator * _Nonnull)chartAnimator;

/// Called when the Animator has stopped.
- (void)chartAnimatorStopped:(ChartAnimator * _Nonnull)chartAnimator;
@end

@class UITouch;
@class UIEvent;
@class NSCoder;

SWIFT_CLASS("_TtC6Charts8NSUIView")
@interface NSUIView : UIView
- (void)touchesBegan:(NSSet<UITouch *> * _Nonnull)touches withEvent:(UIEvent * _Nullable)event;
- (void)touchesMoved:(NSSet<UITouch *> * _Nonnull)touches withEvent:(UIEvent * _Nullable)event;
- (void)touchesEnded:(NSSet<UITouch *> * _Nonnull)touches withEvent:(UIEvent * _Nullable)event;
- (void)touchesCancelled:(NSSet<UITouch *> * _Nullable)touches withEvent:(UIEvent * _Nullable)event;
- (void)nsuiTouchesBegan:(NSSet<UITouch *> * _Nonnull)touches withEvent:(UIEvent * _Nullable)event;
- (void)nsuiTouchesMoved:(NSSet<UITouch *> * _Nonnull)touches withEvent:(UIEvent * _Nullable)event;
- (void)nsuiTouchesEnded:(NSSet<UITouch *> * _Nonnull)touches withEvent:(UIEvent * _Nullable)event;
- (void)nsuiTouchesCancelled:(NSSet<UITouch *> * _Nullable)touches withEvent:(UIEvent * _Nullable)event;
- (nonnull instancetype)initWithFrame:(CGRect)frame OBJC_DESIGNATED_INITIALIZER;
- (nullable instancetype)initWithCoder:(NSCoder * _Nonnull)aDecoder OBJC_DESIGNATED_INITIALIZER;
@end

@class ChartXAxis;
@class ChartMarker;
enum ChartEasingOption : NSInteger;
@class ChartLegend;
@class ChartLegendRenderer;
@class UIImage;
@protocol ChartViewDelegate;

SWIFT_CLASS("_TtC6Charts13ChartViewBase")
@interface ChartViewBase : NSUIView <ChartDataProvider, ChartAnimatorDelegate>

/// \returns  the object representing all x-labels, this method can be used to
/// acquire the XAxis object and modify it (e.g. change the position of the
/// labels)
@property (nonatomic, readonly, strong) ChartXAxis * _Nonnull xAxis;

/// If set to true, chart continues to scroll after touch up
@property (nonatomic) BOOL dragDecelerationEnabled;

/// Font object used for drawing the description text (by default in the bottom right corner of the chart)
@property (nonatomic, strong) UIFont * _Nullable descriptionFont;

/// Text color used for drawing the description text
@property (nonatomic, strong) UIColor * _Nullable descriptionTextColor;

/// Text align used for drawing the description text
@property (nonatomic) NSTextAlignment descriptionTextAlign;

/// font object for drawing the information text when there are no values in the chart
@property (nonatomic, strong) UIFont * _Null_unspecified infoFont;
@property (nonatomic, strong) UIColor * _Null_unspecified infoTextColor;

/// description text that appears in the bottom right corner of the chart
@property (nonatomic, copy) NSString * _Nonnull descriptionText;

/// delegate to receive chart events
@property (nonatomic, weak) id <ChartViewDelegate> _Nullable delegate;

/// text that is displayed when the chart is empty
@property (nonatomic, copy) NSString * _Nonnull noDataText;

/// text that is displayed when the chart is empty that describes why the chart is empty
@property (nonatomic, copy) NSString * _Nullable noDataTextDescription;

/// object responsible for rendering the data
@property (nonatomic, strong) ChartDataRendererBase * _Nullable renderer;
@property (nonatomic, strong) ChartHighlighter * _Nullable highlighter;

/// if set to true, the marker is drawn when a value is clicked
@property (nonatomic) BOOL drawMarkers;

/// the view that represents the marker
@property (nonatomic, strong) ChartMarker * _Nullable marker;

/// An extra offset to be appended to the viewport's top
@property (nonatomic) CGFloat extraTopOffset;

/// An extra offset to be appended to the viewport's right
@property (nonatomic) CGFloat extraRightOffset;

/// An extra offset to be appended to the viewport's bottom
@property (nonatomic) CGFloat extraBottomOffset;

/// An extra offset to be appended to the viewport's left
@property (nonatomic) CGFloat extraLeftOffset;
- (void)setExtraOffsetsWithLeft:(CGFloat)left top:(CGFloat)top right:(CGFloat)right bottom:(CGFloat)bottom;
- (nonnull instancetype)initWithFrame:(CGRect)frame OBJC_DESIGNATED_INITIALIZER;
- (nullable instancetype)initWithCoder:(NSCoder * _Nonnull)aDecoder OBJC_DESIGNATED_INITIALIZER;

/// The data for the chart
@property (nonatomic, strong) ChartData * _Nullable data;

/// Clears the chart from all data (sets it to null) and refreshes it (by calling setNeedsDisplay()).
- (void)clear;

/// Removes all DataSets (and thereby Entries) from the chart. Does not remove the x-values. Also refreshes the chart by calling setNeedsDisplay().
- (void)clearValues;

/// \returns  true if the chart is empty (meaning it's data object is either null or contains no entries).
- (BOOL)isEmpty;

/// Lets the chart know its underlying data has changed and should perform all necessary recalculations. It is crucial that this method is called everytime data is changed dynamically. Not calling this method can lead to crashes or unexpected behaviour.
- (void)notifyDataSetChanged;
- (void)drawRect:(CGRect)rect;

/// \returns  the array of currently highlighted values. This might an empty if nothing is highlighted.
@property (nonatomic, readonly, copy) NSArray<ChartHighlight *> * _Nonnull highlighted;

/// Set this to false to prevent values from being highlighted by tap gesture. Values can still be highlighted via drag or programmatically. default: true
@property (nonatomic) BOOL highlightPerTapEnabled;

/// Returns true if values can be highlighted via tap gesture, false if not.
@property (nonatomic, readonly) BOOL isHighLightPerTapEnabled;

/// Checks if the highlight array is null, has a length of zero or if the first object is null.
///
/// \returns  true if there are values to highlight, false if there are no values to highlight.
- (BOOL)valuesToHighlight;

/// Highlights the values at the given indices in the given DataSets. Provide null or an empty array to undo all highlighting. This should be used to programmatically highlight values. This DOES NOT generate a callback to the delegate.
- (void)highlightValues:(NSArray<ChartHighlight *> * _Nullable)highs;

/// Highlights the values represented by the provided Highlight object This DOES NOT generate a callback to the delegate.
///
/// \param highlight contains information about which entry should be highlighted
- (void)highlightValue:(ChartHighlight * _Nullable)highlight;

/// Highlights the value at the given x-index in the given DataSet. Provide -1 as the x-index to undo all highlighting.
- (void)highlightValueWithXIndex:(NSInteger)xIndex dataSetIndex:(NSInteger)dataSetIndex;

/// Highlights the value at the given x-index in the given DataSet. Provide -1 as the x-index to undo all highlighting.
- (void)highlightValueWithXIndex:(NSInteger)xIndex dataSetIndex:(NSInteger)dataSetIndex callDelegate:(BOOL)callDelegate;

/// Highlights the value selected by touch gesture.
- (void)highlightValueWithHighlight:(ChartHighlight * _Nullable)highlight callDelegate:(BOOL)callDelegate;

/// The last value that was highlighted via touch.
@property (nonatomic, strong) ChartHighlight * _Nullable lastHighlighted;

/// \returns  the actual position in pixels of the MarkerView for the given Entry in the given DataSet.
- (CGPoint)getMarkerPositionWithEntry:(ChartDataEntry * _Nonnull)entry highlight:(ChartHighlight * _Nonnull)highlight;

/// \returns  the animator responsible for animating chart values.
@property (nonatomic, readonly, strong) ChartAnimator * _Null_unspecified chartAnimator;

/// Animates the drawing / rendering of the chart on both x- and y-axis with the specified animation time. If animate(...) is called, no further calling of invalidate() is necessary to refresh the chart.
///
/// \param xAxisDuration duration for animating the x axis
///
/// \param yAxisDuration duration for animating the y axis
///
/// \param easingX an easing function for the animation on the x axis
///
/// \param easingY an easing function for the animation on the y axis
- (void)animateWithXAxisDuration:(NSTimeInterval)xAxisDuration yAxisDuration:(NSTimeInterval)yAxisDuration easingX:(CGFloat (^ _Nullable)(NSTimeInterval elapsed, NSTimeInterval duration))easingX easingY:(CGFloat (^ _Nullable)(NSTimeInterval elapsed, NSTimeInterval duration))easingY;

/// Animates the drawing / rendering of the chart on both x- and y-axis with the specified animation time. If animate(...) is called, no further calling of invalidate() is necessary to refresh the chart.
///
/// \param xAxisDuration duration for animating the x axis
///
/// \param yAxisDuration duration for animating the y axis
///
/// \param easingOptionX the easing function for the animation on the x axis
///
/// \param easingOptionY the easing function for the animation on the y axis
- (void)animateWithXAxisDuration:(NSTimeInterval)xAxisDuration yAxisDuration:(NSTimeInterval)yAxisDuration easingOptionX:(enum ChartEasingOption)easingOptionX easingOptionY:(enum ChartEasingOption)easingOptionY;

/// Animates the drawing / rendering of the chart on both x- and y-axis with the specified animation time. If animate(...) is called, no further calling of invalidate() is necessary to refresh the chart.
///
/// \param xAxisDuration duration for animating the x axis
///
/// \param yAxisDuration duration for animating the y axis
///
/// \param easing an easing function for the animation
- (void)animateWithXAxisDuration:(NSTimeInterval)xAxisDuration yAxisDuration:(NSTimeInterval)yAxisDuration easing:(CGFloat (^ _Nullable)(NSTimeInterval elapsed, NSTimeInterval duration))easing;

/// Animates the drawing / rendering of the chart on both x- and y-axis with the specified animation time. If animate(...) is called, no further calling of invalidate() is necessary to refresh the chart.
///
/// \param xAxisDuration duration for animating the x axis
///
/// \param yAxisDuration duration for animating the y axis
///
/// \param easingOption the easing function for the animation
- (void)animateWithXAxisDuration:(NSTimeInterval)xAxisDuration yAxisDuration:(NSTimeInterval)yAxisDuration easingOption:(enum ChartEasingOption)easingOption;

/// Animates the drawing / rendering of the chart on both x- and y-axis with the specified animation time. If animate(...) is called, no further calling of invalidate() is necessary to refresh the chart.
///
/// \param xAxisDuration duration for animating the x axis
///
/// \param yAxisDuration duration for animating the y axis
- (void)animateWithXAxisDuration:(NSTimeInterval)xAxisDuration yAxisDuration:(NSTimeInterval)yAxisDuration;

/// Animates the drawing / rendering of the chart the x-axis with the specified animation time. If animate(...) is called, no further calling of invalidate() is necessary to refresh the chart.
///
/// \param xAxisDuration duration for animating the x axis
///
/// \param easing an easing function for the animation
- (void)animateWithXAxisDuration:(NSTimeInterval)xAxisDuration easing:(CGFloat (^ _Nullable)(NSTimeInterval elapsed, NSTimeInterval duration))easing;

/// Animates the drawing / rendering of the chart the x-axis with the specified animation time. If animate(...) is called, no further calling of invalidate() is necessary to refresh the chart.
///
/// \param xAxisDuration duration for animating the x axis
///
/// \param easingOption the easing function for the animation
- (void)animateWithXAxisDuration:(NSTimeInterval)xAxisDuration easingOption:(enum ChartEasingOption)easingOption;

/// Animates the drawing / rendering of the chart the x-axis with the specified animation time. If animate(...) is called, no further calling of invalidate() is necessary to refresh the chart.
///
/// \param xAxisDuration duration for animating the x axis
- (void)animateWithXAxisDuration:(NSTimeInterval)xAxisDuration;

/// Animates the drawing / rendering of the chart the y-axis with the specified animation time. If animate(...) is called, no further calling of invalidate() is necessary to refresh the chart.
///
/// \param yAxisDuration duration for animating the y axis
///
/// \param easing an easing function for the animation
- (void)animateWithYAxisDuration:(NSTimeInterval)yAxisDuration easing:(CGFloat (^ _Nullable)(NSTimeInterval elapsed, NSTimeInterval duration))easing;

/// Animates the drawing / rendering of the chart the y-axis with the specified animation time. If animate(...) is called, no further calling of invalidate() is necessary to refresh the chart.
///
/// \param yAxisDuration duration for animating the y axis
///
/// \param easingOption the easing function for the animation
- (void)animateWithYAxisDuration:(NSTimeInterval)yAxisDuration easingOption:(enum ChartEasingOption)easingOption;

/// Animates the drawing / rendering of the chart the y-axis with the specified animation time. If animate(...) is called, no further calling of invalidate() is necessary to refresh the chart.
///
/// \param yAxisDuration duration for animating the y axis
- (void)animateWithYAxisDuration:(NSTimeInterval)yAxisDuration;

/// \returns  the current y-max value across all DataSets
@property (nonatomic, readonly) double chartYMax;

/// \returns  the current y-min value across all DataSets
@property (nonatomic, readonly) double chartYMin;
@property (nonatomic, readonly) double chartXMax;
@property (nonatomic, readonly) double chartXMin;
@property (nonatomic, readonly) NSInteger xValCount;

/// \returns  the total number of (y) values the chart holds (across all DataSets)
@property (nonatomic, readonly) NSInteger valueCount;

/// Note: (Equivalent of getCenter() in MPAndroidChart, as center is already a standard in iOS that returns the center point relative to superview, and MPAndroidChart returns relative to self)
///
/// \returns  the center point of the chart (the whole View) in pixels.
@property (nonatomic, readonly) CGPoint midPoint;
- (void)setDescriptionTextPositionWithX:(CGFloat)x y:(CGFloat)y;

/// \returns  the center of the chart taking offsets under consideration. (returns the center of the content rectangle)
@property (nonatomic, readonly) CGPoint centerOffsets;

/// \returns  the Legend object of the chart. This method can be used to get an instance of the legend in order to customize the automatically generated Legend.
@property (nonatomic, readonly, strong) ChartLegend * _Nonnull legend;

/// \returns  the renderer object responsible for rendering / drawing the Legend.
@property (nonatomic, readonly, strong) ChartLegendRenderer * _Null_unspecified legendRenderer;

/// \returns  the rectangle that defines the borders of the chart-value surface (into which the actual values are drawn).
@property (nonatomic, readonly) CGRect contentRect;

/// \returns  the x-value at the given index
- (NSString * _Null_unspecified)getXValue:(NSInteger)index;

/// Get all Entry objects at the given index across all DataSets.
- (NSArray<ChartDataEntry *> * _Nonnull)getEntriesAtIndex:(NSInteger)xIndex;

/// \returns  the ViewPortHandler of the chart that is responsible for the
/// content area of the chart and its offsets and dimensions.
@property (nonatomic, readonly, strong) ChartViewPortHandler * _Null_unspecified viewPortHandler;

/// \returns  the bitmap that represents the chart.
- (UIImage * _Nullable)getChartImageWithTransparent:(BOOL)transparent;

/// Saves the current state of the chart to the camera roll
- (void)saveToCameraRoll;
- (void)observeValueForKeyPath:(NSString * _Nullable)keyPath ofObject:(id _Nullable)object change:(NSDictionary<NSString *, id> * _Nullable)change context:(void * _Null_unspecified)context;
- (void)clearAllViewportJobs;

/// default: true
///
/// \returns  true if chart continues to scroll after touch up, false if not.
@property (nonatomic, readonly) BOOL isDragDecelerationEnabled;

/// Deceleration friction coefficient in [0 ; 1] interval, higher values indicate that speed will decrease slowly, for example if it set to 0, it will stop immediately. 1 is an invalid value, and will be converted to 0.999 automatically.
///
/// <em>default</em>: true
@property (nonatomic) CGFloat dragDecelerationFrictionCoef;
- (void)chartAnimatorUpdated:(ChartAnimator * _Nonnull)chartAnimator;
- (void)chartAnimatorStopped:(ChartAnimator * _Nonnull)chartAnimator;
- (void)nsuiTouchesBegan:(NSSet<UITouch *> * _Nonnull)touches withEvent:(UIEvent * _Nullable)event;
- (void)nsuiTouchesMoved:(NSSet<UITouch *> * _Nonnull)touches withEvent:(UIEvent * _Nullable)event;
- (void)nsuiTouchesEnded:(NSSet<UITouch *> * _Nonnull)touches withEvent:(UIEvent * _Nullable)event;
- (void)nsuiTouchesCancelled:(NSSet<UITouch *> * _Nullable)touches withEvent:(UIEvent * _Nullable)event;
@end

@class UIGestureRecognizer;
@class ChartYAxis;
@class ChartXAxisRenderer;
@class ChartYAxisRenderer;


/// Base-class of LineChart, BarChart, ScatterChart and CandleStickChart.
SWIFT_CLASS("_TtC6Charts20BarLineChartViewBase")
@interface BarLineChartViewBase : ChartViewBase <BarLineScatterCandleBubbleChartDataProvider, UIGestureRecognizerDelegate>

/// the color for the background of the chart-drawing area (everything behind the grid lines).
@property (nonatomic, strong) UIColor * _Nonnull gridBackgroundColor;
@property (nonatomic, strong) UIColor * _Nonnull borderColor;
@property (nonatomic) CGFloat borderLineWidth;

/// flag indicating if the grid background should be drawn or not
@property (nonatomic) BOOL drawGridBackgroundEnabled;

/// Sets drawing the borders rectangle to true. If this is enabled, there is no point drawing the axis-lines of x- and y-axis.
@property (nonatomic) BOOL drawBordersEnabled;

/// Sets the minimum offset (padding) around the chart, defaults to 10
@property (nonatomic) CGFloat minOffset;

/// Sets whether the chart should keep its position (zoom / scroll) after a rotation (orientation change) default: false
@property (nonatomic) BOOL keepPositionOnRotation;
- (nonnull instancetype)initWithFrame:(CGRect)frame OBJC_DESIGNATED_INITIALIZER;
- (nullable instancetype)initWithCoder:(NSCoder * _Nonnull)aDecoder OBJC_DESIGNATED_INITIALIZER;
- (void)observeValueForKeyPath:(NSString * _Nullable)keyPath ofObject:(id _Nullable)object change:(NSDictionary<NSString *, id> * _Nullable)change context:(void * _Null_unspecified)context;
- (void)drawRect:(CGRect)rect;
- (void)notifyDataSetChanged;
- (CGPoint)getMarkerPositionWithEntry:(ChartDataEntry * _Nonnull)e highlight:(ChartHighlight * _Nonnull)highlight;
- (void)stopDeceleration;
- (BOOL)gestureRecognizerShouldBegin:(UIGestureRecognizer * _Nonnull)gestureRecognizer;
- (BOOL)gestureRecognizer:(UIGestureRecognizer * _Nonnull)gestureRecognizer shouldRecognizeSimultaneouslyWithGestureRecognizer:(UIGestureRecognizer * _Nonnull)otherGestureRecognizer;

/// MARK: Viewport modifiers Zooms in by 1.4, into the charts center. center.
- (void)zoomIn;

/// Zooms out by 0.7, from the charts center. center.
- (void)zoomOut;

/// Zooms in or out by the given scale factor. x and y are the coordinates (in pixels) of the zoom center.
///
/// \param scaleX if < 1 --> zoom out, if > 1 --> zoom in
///
/// \param scaleY if < 1 --> zoom out, if > 1 --> zoom in
///
/// \param x 
///
/// \param y 
- (void)zoom:(CGFloat)scaleX scaleY:(CGFloat)scaleY x:(CGFloat)x y:(CGFloat)y;

/// Zooms in or out by the given scale factor. x and y are the values (not pixels) which to zoom to or from (the values of the zoom center).
///
/// \param scaleX if < 1 --> zoom out, if > 1 --> zoom in
///
/// \param scaleY if < 1 --> zoom out, if > 1 --> zoom in
///
/// \param xIndex 
///
/// \param yValue 
///
/// \param axis 
- (void)zoom:(CGFloat)scaleX scaleY:(CGFloat)scaleY xIndex:(CGFloat)xIndex yValue:(double)yValue axis:(enum AxisDependency)axis;

/// Zooms by the specified scale factor to the specified values on the specified axis.
///
/// \param scaleX 
///
/// \param scaleY 
///
/// \param xIndex 
///
/// \param yValue 
///
/// \param axis which axis should be used as a reference for the y-axis
///
/// \param duration the duration of the animation in seconds
///
/// \param easing 
- (void)zoomAndCenterViewAnimatedWithScaleX:(CGFloat)scaleX scaleY:(CGFloat)scaleY xIndex:(CGFloat)xIndex yValue:(double)yValue axis:(enum AxisDependency)axis duration:(NSTimeInterval)duration easing:(CGFloat (^ _Nullable)(NSTimeInterval elapsed, NSTimeInterval duration))easing;

/// Zooms by the specified scale factor to the specified values on the specified axis.
///
/// \param scaleX 
///
/// \param scaleY 
///
/// \param xIndex 
///
/// \param yValue 
///
/// \param axis which axis should be used as a reference for the y-axis
///
/// \param duration the duration of the animation in seconds
///
/// \param easing 
- (void)zoomAndCenterViewAnimatedWithScaleX:(CGFloat)scaleX scaleY:(CGFloat)scaleY xIndex:(CGFloat)xIndex yValue:(double)yValue axis:(enum AxisDependency)axis duration:(NSTimeInterval)duration easingOption:(enum ChartEasingOption)easingOption;

/// Zooms by the specified scale factor to the specified values on the specified axis.
///
/// \param scaleX 
///
/// \param scaleY 
///
/// \param xIndex 
///
/// \param yValue 
///
/// \param axis which axis should be used as a reference for the y-axis
///
/// \param duration the duration of the animation in seconds
///
/// \param easing 
- (void)zoomAndCenterViewAnimatedWithScaleX:(CGFloat)scaleX scaleY:(CGFloat)scaleY xIndex:(CGFloat)xIndex yValue:(double)yValue axis:(enum AxisDependency)axis duration:(NSTimeInterval)duration;

/// Resets all zooming and dragging and makes the chart fit exactly it's bounds.
- (void)fitScreen;

/// Sets the minimum scale value to which can be zoomed out. 1 = fitScreen
- (void)setScaleMinima:(CGFloat)scaleX scaleY:(CGFloat)scaleY;

/// Sets the size of the area (range on the x-axis) that should be maximum visible at once (no further zomming out allowed). If this is e.g. set to 10, no more than 10 values on the x-axis can be viewed at once without scrolling.
- (void)setVisibleXRangeMaximum:(CGFloat)maxXRange;

/// Sets the size of the area (range on the x-axis) that should be minimum visible at once (no further zooming in allowed). If this is e.g. set to 10, no less than 10 values on the x-axis can be viewed at once without scrolling.
- (void)setVisibleXRangeMinimum:(CGFloat)minXRange;

/// Limits the maximum and minimum value count that can be visible by pinching and zooming. e.g. minRange=10, maxRange=100 no less than 10 values and no more that 100 values can be viewed at once without scrolling
- (void)setVisibleXRangeWithMinXRange:(CGFloat)minXRange maxXRange:(CGFloat)maxXRange;

/// Sets the size of the area (range on the y-axis) that should be maximum visible at once.
///
/// \param yRange 
///
/// \param axis - the axis for which this limit should apply
- (void)setVisibleYRangeMaximum:(CGFloat)maxYRange axis:(enum AxisDependency)axis;

/// Moves the left side of the current viewport to the specified x-index. This also refreshes the chart by calling setNeedsDisplay().
- (void)moveViewToX:(CGFloat)xIndex;

/// Centers the viewport to the specified y-value on the y-axis. This also refreshes the chart by calling setNeedsDisplay().
///
/// \param yValue 
///
/// \param axis - which axis should be used as a reference for the y-axis
- (void)moveViewToY:(double)yValue axis:(enum AxisDependency)axis;

/// This will move the left side of the current viewport to the specified x-index on the x-axis, and center the viewport to the specified y-value on the y-axis. This also refreshes the chart by calling setNeedsDisplay().
///
/// \param xIndex 
///
/// \param yValue 
///
/// \param axis - which axis should be used as a reference for the y-axis
- (void)moveViewToXIndex:(CGFloat)xIndex yValue:(double)yValue axis:(enum AxisDependency)axis;

/// This will move the left side of the current viewport to the specified x-position and center the viewport to the specified y-position animated. This also refreshes the chart by calling setNeedsDisplay().
///
/// \param xIndex 
///
/// \param yValue 
///
/// \param axis which axis should be used as a reference for the y-axis
///
/// \param duration the duration of the animation in seconds
///
/// \param easing 
- (void)moveViewToAnimatedWithXIndex:(CGFloat)xIndex yValue:(double)yValue axis:(enum AxisDependency)axis duration:(NSTimeInterval)duration easing:(CGFloat (^ _Nullable)(NSTimeInterval elapsed, NSTimeInterval duration))easing;

/// This will move the left side of the current viewport to the specified x-position and center the viewport to the specified y-position animated. This also refreshes the chart by calling setNeedsDisplay().
///
/// \param xIndex 
///
/// \param yValue 
///
/// \param axis which axis should be used as a reference for the y-axis
///
/// \param duration the duration of the animation in seconds
///
/// \param easing 
- (void)moveViewToAnimatedWithXIndex:(CGFloat)xIndex yValue:(double)yValue axis:(enum AxisDependency)axis duration:(NSTimeInterval)duration easingOption:(enum ChartEasingOption)easingOption;

/// This will move the left side of the current viewport to the specified x-position and center the viewport to the specified y-position animated. This also refreshes the chart by calling setNeedsDisplay().
///
/// \param xIndex 
///
/// \param yValue 
///
/// \param axis which axis should be used as a reference for the y-axis
///
/// \param duration the duration of the animation in seconds
///
/// \param easing 
- (void)moveViewToAnimatedWithXIndex:(CGFloat)xIndex yValue:(double)yValue axis:(enum AxisDependency)axis duration:(NSTimeInterval)duration;

/// This will move the center of the current viewport to the specified x-index and y-value. This also refreshes the chart by calling setNeedsDisplay().
///
/// \param xIndex 
///
/// \param yValue 
///
/// \param axis - which axis should be used as a reference for the y-axis
- (void)centerViewToXIndex:(CGFloat)xIndex yValue:(double)yValue axis:(enum AxisDependency)axis;

/// This will move the center of the current viewport to the specified x-value and y-value animated.
///
/// \param xIndex 
///
/// \param yValue 
///
/// \param axis which axis should be used as a reference for the y-axis
///
/// \param duration the duration of the animation in seconds
///
/// \param easing 
- (void)centerViewToAnimatedWithXIndex:(CGFloat)xIndex yValue:(double)yValue axis:(enum AxisDependency)axis duration:(NSTimeInterval)duration easing:(CGFloat (^ _Nullable)(NSTimeInterval elapsed, NSTimeInterval duration))easing;

/// This will move the center of the current viewport to the specified x-value and y-value animated.
///
/// \param xIndex 
///
/// \param yValue 
///
/// \param axis which axis should be used as a reference for the y-axis
///
/// \param duration the duration of the animation in seconds
///
/// \param easing 
- (void)centerViewToAnimatedWithXIndex:(CGFloat)xIndex yValue:(double)yValue axis:(enum AxisDependency)axis duration:(NSTimeInterval)duration easingOption:(enum ChartEasingOption)easingOption;

/// This will move the center of the current viewport to the specified x-value and y-value animated.
///
/// \param xIndex 
///
/// \param yValue 
///
/// \param axis which axis should be used as a reference for the y-axis
///
/// \param duration the duration of the animation in seconds
///
/// \param easing 
- (void)centerViewToAnimatedWithXIndex:(CGFloat)xIndex yValue:(double)yValue axis:(enum AxisDependency)axis duration:(NSTimeInterval)duration;

/// Sets custom offsets for the current ChartViewPort (the offsets on the sides of the actual chart window). Setting this will prevent the chart from automatically calculating it's offsets. Use resetViewPortOffsets() to undo this. ONLY USE THIS WHEN YOU KNOW WHAT YOU ARE DOING, else use setExtraOffsets(...).
- (void)setViewPortOffsetsWithLeft:(CGFloat)left top:(CGFloat)top right:(CGFloat)right bottom:(CGFloat)bottom;

/// Resets all custom offsets set via setViewPortOffsets(...) method. Allows the chart to again calculate all offsets automatically.
- (void)resetViewPortOffsets;

/// \returns  the delta-y value (y-value range) of the specified axis.
- (CGFloat)getDeltaY:(enum AxisDependency)axis;

/// \returns  the position (in pixels) the provided Entry has inside the chart view
- (CGPoint)getPosition:(ChartDataEntry * _Nonnull)e axis:(enum AxisDependency)axis;

/// is dragging enabled? (moving the chart with the finger) for the chart (this does not affect scaling).
@property (nonatomic) BOOL dragEnabled;

/// is dragging enabled? (moving the chart with the finger) for the chart (this does not affect scaling).
@property (nonatomic, readonly) BOOL isDragEnabled;

/// is scaling enabled? (zooming in and out by gesture) for the chart (this does not affect dragging).
- (void)setScaleEnabled:(BOOL)enabled;
@property (nonatomic) BOOL scaleXEnabled;
@property (nonatomic) BOOL scaleYEnabled;
@property (nonatomic, readonly) BOOL isScaleXEnabled;
@property (nonatomic, readonly) BOOL isScaleYEnabled;

/// flag that indicates if double tap zoom is enabled or not
@property (nonatomic) BOOL doubleTapToZoomEnabled;

/// default: true
///
/// \returns  true if zooming via double-tap is enabled false if not.
@property (nonatomic, readonly) BOOL isDoubleTapToZoomEnabled;

/// flag that indicates if highlighting per dragging over a fully zoomed out chart is enabled
@property (nonatomic) BOOL highlightPerDragEnabled;

/// If set to true, highlighting per dragging over a fully zoomed out chart is enabled You might want to disable this when using inside a NSUIScrollView
///
/// <em>default</em>: true
@property (nonatomic, readonly) BOOL isHighlightPerDragEnabled;

/// Set this to true to make the highlight full-bar oriented, false to make it highlight single values
@property (nonatomic) BOOL highlightFullBarEnabled;

/// \returns  true the highlight is be full-bar oriented, false if single-value
@property (nonatomic, readonly) BOOL isHighlightFullBarEnabled;

/// default: true
///
/// \returns  true if drawing the grid background is enabled, false if not.
@property (nonatomic, readonly) BOOL isDrawGridBackgroundEnabled;

/// default: false
///
/// \returns  true if drawing the borders rectangle is enabled, false if not.
@property (nonatomic, readonly) BOOL isDrawBordersEnabled;

/// \returns  the Highlight object (contains x-index and DataSet index) of the selected value at the given touch point inside the Line-, Scatter-, or CandleStick-Chart.
- (ChartHighlight * _Nullable)getHighlightByTouchPoint:(CGPoint)pt;

/// \returns  the x and y values in the chart at the given touch point
/// (encapsulated in a <code>CGPoint
/// </code>). This method transforms pixel coordinates to
/// coordinates / values in the chart. This is the opposite method to
/// <code>getPixelsForValues(...)
/// </code>.
- (CGPoint)getValueByTouchPointWithPt:(CGPoint)pt axis:(enum AxisDependency)axis;

/// Transforms the given chart values into pixels. This is the opposite method to getValueByTouchPoint(...).
- (CGPoint)getPixelForValue:(double)x y:(double)y axis:(enum AxisDependency)axis;

/// \returns  the y-value at the given touch position (must not necessarily be
/// a value contained in one of the datasets)
- (CGFloat)getYValueByTouchPointWithPt:(CGPoint)pt axis:(enum AxisDependency)axis;

/// \returns  the Entry object displayed at the touched position of the chart
- (ChartDataEntry * _Null_unspecified)getEntryByTouchPoint:(CGPoint)pt;

/// \returns  the DataSet object displayed at the touched position of the chart
- (id <IBarLineScatterCandleBubbleChartDataSet> _Null_unspecified)getDataSetByTouchPoint:(CGPoint)pt;

/// \returns  the current x-scale factor
@property (nonatomic, readonly) CGFloat scaleX;

/// \returns  the current y-scale factor
@property (nonatomic, readonly) CGFloat scaleY;

/// if the chart is fully zoomed out, return true
@property (nonatomic, readonly) BOOL isFullyZoomedOut;

/// \returns  the left y-axis object. In the horizontal bar-chart, this is the
/// top axis.
@property (nonatomic, readonly, strong) ChartYAxis * _Nonnull leftAxis;

/// \returns  the right y-axis object. In the horizontal bar-chart, this is the
/// bottom axis.
@property (nonatomic, readonly, strong) ChartYAxis * _Nonnull rightAxis;

/// \returns  the y-axis object to the corresponding AxisDependency. In the
/// horizontal bar-chart, LEFT == top, RIGHT == BOTTOM
- (ChartYAxis * _Nonnull)getAxis:(enum AxisDependency)axis;

/// flag that indicates if pinch-zoom is enabled. if true, both x and y axis can be scaled simultaneously with 2 fingers, if false, x and y axis can be scaled separately
@property (nonatomic) BOOL pinchZoomEnabled;

/// default: false
///
/// \returns  true if pinch-zoom is enabled, false if not
@property (nonatomic, readonly) BOOL isPinchZoomEnabled;

/// Set an offset in dp that allows the user to drag the chart over it's bounds on the x-axis.
- (void)setDragOffsetX:(CGFloat)offset;

/// Set an offset in dp that allows the user to drag the chart over it's bounds on the y-axis.
- (void)setDragOffsetY:(CGFloat)offset;

/// \returns  true if both drag offsets (x and y) are zero or smaller.
@property (nonatomic, readonly) BOOL hasNoDragOffset;

/// The X axis renderer. This is a read-write property so you can set your own custom renderer here. default: An instance of ChartXAxisRenderer
///
/// \returns  The current set X axis renderer
@property (nonatomic, strong) ChartXAxisRenderer * _Nonnull xAxisRenderer;

/// The left Y axis renderer. This is a read-write property so you can set your own custom renderer here. default: An instance of ChartYAxisRenderer
///
/// \returns  The current set left Y axis renderer
@property (nonatomic, strong) ChartYAxisRenderer * _Nonnull leftYAxisRenderer;

/// The right Y axis renderer. This is a read-write property so you can set your own custom renderer here. default: An instance of ChartYAxisRenderer
///
/// \returns  The current set right Y axis renderer
@property (nonatomic, strong) ChartYAxisRenderer * _Nonnull rightYAxisRenderer;
@property (nonatomic, readonly) double chartYMax;
@property (nonatomic, readonly) double chartYMin;

/// \returns  true if either the left or the right or both axes are inverted.
@property (nonatomic, readonly) BOOL isAnyAxisInverted;

/// flag that indicates if auto scaling on the y axis is enabled. if yes, the y axis automatically adjusts to the min and max y values of the current x axis range whenever the viewport changes
@property (nonatomic) BOOL autoScaleMinMaxEnabled;

/// default: false
///
/// \returns  true if auto scaling on the y axis is enabled.
@property (nonatomic, readonly) BOOL isAutoScaleMinMaxEnabled;

/// Sets a minimum width to the specified y axis.
- (void)setYAxisMinWidth:(enum AxisDependency)which width:(CGFloat)width;

/// default: 0.0
///
/// \returns  the (custom) minimum width of the specified Y axis.
- (CGFloat)getYAxisMinWidth:(enum AxisDependency)which;

/// Sets a maximum width to the specified y axis. Zero (0.0) means there's no maximum width
- (void)setYAxisMaxWidth:(enum AxisDependency)which width:(CGFloat)width;

/// Zero (0.0) means there's no maximum width
///
/// <em>default</em>: 0.0 (no maximum specified)
///
/// \returns  the (custom) maximum width of the specified Y axis.
- (CGFloat)getYAxisMaxWidth:(enum AxisDependency)which;

/// <ul><li>returns the width of the specified y axis.</li></ul>
- (CGFloat)getYAxisWidth:(enum AxisDependency)which;

/// \returns  the Transformer class that contains all matrices and is
/// responsible for transforming values into pixels on the screen and
/// backwards.
- (ChartTransformer * _Nonnull)getTransformer:(enum AxisDependency)which;

/// the number of maximum visible drawn values on the chart only active when setDrawValues() is enabled
@property (nonatomic) NSInteger maxVisibleValueCount;
- (BOOL)isInverted:(enum AxisDependency)axis;

/// \returns  the lowest x-index (value on the x-axis) that is still visible on he chart.
@property (nonatomic, readonly) NSInteger lowestVisibleXIndex;

/// \returns  the highest x-index (value on the x-axis) that is still visible on the chart.
@property (nonatomic, readonly) NSInteger highestVisibleXIndex;
@end



/// Chart that draws bars.
SWIFT_CLASS("_TtC6Charts12BarChartView")
@interface BarChartView : BarLineChartViewBase <BarChartDataProvider>

/// \returns  the Highlight object (contains x-index and DataSet index) of the selected value at the given touch point inside the BarChart.
- (ChartHighlight * _Nullable)getHighlightByTouchPoint:(CGPoint)pt;

/// \returns  the bounding box of the specified Entry in the specified DataSet. Returns null if the Entry could not be found in the charts data.
- (CGRect)getBarBounds:(BarChartDataEntry * _Nonnull)e;
@property (nonatomic, readonly) NSInteger lowestVisibleXIndex;
@property (nonatomic, readonly) NSInteger highestVisibleXIndex;

/// flag that enables or disables the highlighting arrow
@property (nonatomic) BOOL drawHighlightArrowEnabled;

/// if set to true, all values are drawn above their bars, instead of below their top
@property (nonatomic) BOOL drawValueAboveBarEnabled;

/// if set to true, a grey area is drawn behind each bar that indicates the maximum value
@property (nonatomic) BOOL drawBarShadowEnabled;
@property (nonatomic, readonly, strong) BarChartData * _Nullable barData;

/// \returns  true if drawing the highlighting arrow is enabled, false if not
@property (nonatomic, readonly) BOOL isDrawHighlightArrowEnabled;

/// \returns  true if drawing values above bars is enabled, false if not
@property (nonatomic, readonly) BOOL isDrawValueAboveBarEnabled;

/// \returns  true if drawing shadows (maxvalue) for each bar is enabled, false if not
@property (nonatomic, readonly) BOOL isDrawBarShadowEnabled;
- (nonnull instancetype)initWithFrame:(CGRect)frame OBJC_DESIGNATED_INITIALIZER;
- (nullable instancetype)initWithCoder:(NSCoder * _Nonnull)aDecoder OBJC_DESIGNATED_INITIALIZER;
@end






SWIFT_CLASS("_TtC6Charts15BubbleChartData")
@interface BubbleChartData : BarLineScatterCandleBubbleChartData
- (nonnull instancetype)init OBJC_DESIGNATED_INITIALIZER;
- (nonnull instancetype)initWithXVals:(NSArray<NSObject *> * _Nullable)xVals dataSets:(NSArray<id <IChartDataSet>> * _Nullable)dataSets OBJC_DESIGNATED_INITIALIZER;

/// Sets the width of the circle that surrounds the bubble when highlighted for all DataSet objects this data object contains
- (void)setHighlightCircleWidth:(CGFloat)width;
@end


SWIFT_CLASS("_TtC6Charts20BubbleChartDataEntry")
@interface BubbleChartDataEntry : ChartDataEntry

/// The size of the bubble.
@property (nonatomic) CGFloat size;
- (nonnull instancetype)init OBJC_DESIGNATED_INITIALIZER;

/// \param xIndex The index on the x-axis.
///
/// \param val The value on the y-axis.
///
/// \param size The size of the bubble.
- (nonnull instancetype)initWithXIndex:(NSInteger)xIndex value:(double)value size:(CGFloat)size OBJC_DESIGNATED_INITIALIZER;

/// \param xIndex The index on the x-axis.
///
/// \param val The value on the y-axis.
///
/// \param size The size of the bubble.
///
/// \param data Spot for additional data this Entry represents.
- (nonnull instancetype)initWithXIndex:(NSInteger)xIndex value:(double)value size:(CGFloat)size data:(id _Nullable)data OBJC_DESIGNATED_INITIALIZER;
- (id _Nonnull)copyWithZone:(struct _NSZone * _Null_unspecified)zone;
@end


SWIFT_PROTOCOL("_TtP6Charts23BubbleChartDataProvider_")
@protocol BubbleChartDataProvider <BarLineScatterCandleBubbleChartDataProvider>
@property (nonatomic, readonly, strong) BubbleChartData * _Nullable bubbleData;
@end


SWIFT_PROTOCOL("_TtP6Charts19IBubbleChartDataSet_")
@protocol IBubbleChartDataSet <IBarLineScatterCandleBubbleChartDataSet>
@property (nonatomic, readonly) double xMin;
@property (nonatomic, readonly) double xMax;
@property (nonatomic, readonly) CGFloat maxSize;
@property (nonatomic, readonly) BOOL isNormalizeSizeEnabled;

/// Sets/gets the width of the circle that surrounds the bubble when highlighted
@property (nonatomic) CGFloat highlightCircleWidth;
@end


SWIFT_CLASS("_TtC6Charts18BubbleChartDataSet")
@interface BubbleChartDataSet : BarLineScatterCandleBubbleChartDataSet <IBubbleChartDataSet>
@property (nonatomic, readonly) double xMin;
@property (nonatomic, readonly) double xMax;
@property (nonatomic, readonly) CGFloat maxSize;
@property (nonatomic) BOOL normalizeSizeEnabled;
@property (nonatomic, readonly) BOOL isNormalizeSizeEnabled;
- (void)calcMinMaxWithStart:(NSInteger)start end:(NSInteger)end;

/// Sets/gets the width of the circle that surrounds the bubble when highlighted
@property (nonatomic) CGFloat highlightCircleWidth;
- (id _Nonnull)copyWithZone:(struct _NSZone * _Null_unspecified)zone;
- (nonnull instancetype)init OBJC_DESIGNATED_INITIALIZER;
- (nonnull instancetype)initWithLabel:(NSString * _Nullable)label OBJC_DESIGNATED_INITIALIZER;
- (nonnull instancetype)initWithYVals:(NSArray<ChartDataEntry *> * _Nullable)yVals label:(NSString * _Nullable)label OBJC_DESIGNATED_INITIALIZER;
@end


SWIFT_CLASS("_TtC6Charts19BubbleChartRenderer")
@interface BubbleChartRenderer : ChartDataRendererBase
@property (nonatomic, weak) id <BubbleChartDataProvider> _Nullable dataProvider;
- (nonnull instancetype)initWithDataProvider:(id <BubbleChartDataProvider> _Nullable)dataProvider animator:(ChartAnimator * _Nullable)animator viewPortHandler:(ChartViewPortHandler * _Nonnull)viewPortHandler OBJC_DESIGNATED_INITIALIZER;
- (void)drawDataWithContext:(CGContextRef _Nonnull)context;
- (void)drawDataSetWithContext:(CGContextRef _Nonnull)context dataSet:(id <IBubbleChartDataSet> _Nonnull)dataSet;
- (void)drawValuesWithContext:(CGContextRef _Nonnull)context;
- (void)drawExtrasWithContext:(CGContextRef _Nonnull)context;
- (void)drawHighlightedWithContext:(CGContextRef _Nonnull)context indices:(NSArray<ChartHighlight *> * _Nonnull)indices;
@end


SWIFT_CLASS("_TtC6Charts15BubbleChartView")
@interface BubbleChartView : BarLineChartViewBase <BubbleChartDataProvider>
- (void)initialize;
- (void)calcMinMax;
@property (nonatomic, readonly, strong) BubbleChartData * _Nullable bubbleData;
- (nonnull instancetype)initWithFrame:(CGRect)frame OBJC_DESIGNATED_INITIALIZER;
- (nullable instancetype)initWithCoder:(NSCoder * _Nonnull)aDecoder OBJC_DESIGNATED_INITIALIZER;
@end


SWIFT_CLASS("_TtC6Charts15CandleChartData")
@interface CandleChartData : BarLineScatterCandleBubbleChartData
- (nonnull instancetype)init OBJC_DESIGNATED_INITIALIZER;
- (nonnull instancetype)initWithXVals:(NSArray<NSObject *> * _Nullable)xVals dataSets:(NSArray<id <IChartDataSet>> * _Nullable)dataSets OBJC_DESIGNATED_INITIALIZER;
@end


SWIFT_CLASS("_TtC6Charts20CandleChartDataEntry")
@interface CandleChartDataEntry : ChartDataEntry

/// shadow-high value
@property (nonatomic) double high;

/// shadow-low value
@property (nonatomic) double low;

/// close value
@property (nonatomic) double close;

/// open value
@property (nonatomic) double open;
- (nonnull instancetype)init OBJC_DESIGNATED_INITIALIZER;
- (nonnull instancetype)initWithXIndex:(NSInteger)xIndex shadowH:(double)shadowH shadowL:(double)shadowL open:(double)open close:(double)close OBJC_DESIGNATED_INITIALIZER;
- (nonnull instancetype)initWithXIndex:(NSInteger)xIndex shadowH:(double)shadowH shadowL:(double)shadowL open:(double)open close:(double)close data:(id _Nullable)data OBJC_DESIGNATED_INITIALIZER;

/// \returns  the overall range (difference) between shadow-high and shadow-low.
@property (nonatomic, readonly) double shadowRange;

/// \returns  the body size (difference between open and close).
@property (nonatomic, readonly) double bodyRange;

/// the center value of the candle. (Middle value between high and low)
@property (nonatomic) double value;
- (id _Nonnull)copyWithZone:(struct _NSZone * _Null_unspecified)zone;
@end


SWIFT_PROTOCOL("_TtP6Charts23CandleChartDataProvider_")
@protocol CandleChartDataProvider <BarLineScatterCandleBubbleChartDataProvider>
@property (nonatomic, readonly, strong) CandleChartData * _Nullable candleData;
@end


SWIFT_PROTOCOL("_TtP6Charts35ILineScatterCandleRadarChartDataSet_")
@protocol ILineScatterCandleRadarChartDataSet <IBarLineScatterCandleBubbleChartDataSet>

/// Enables / disables the horizontal highlight-indicator. If disabled, the indicator is not drawn.
@property (nonatomic) BOOL drawHorizontalHighlightIndicatorEnabled;

/// Enables / disables the vertical highlight-indicator. If disabled, the indicator is not drawn.
@property (nonatomic) BOOL drawVerticalHighlightIndicatorEnabled;

/// \returns  true if horizontal highlight indicator lines are enabled (drawn)
@property (nonatomic, readonly) BOOL isHorizontalHighlightIndicatorEnabled;

/// \returns  true if vertical highlight indicator lines are enabled (drawn)
@property (nonatomic, readonly) BOOL isVerticalHighlightIndicatorEnabled;

/// Enables / disables both vertical and horizontal highlight-indicators. :param: enabled
- (void)setDrawHighlightIndicators:(BOOL)enabled;
@end


SWIFT_PROTOCOL("_TtP6Charts19ICandleChartDataSet_")
@protocol ICandleChartDataSet <ILineScatterCandleRadarChartDataSet>

/// the space that is left out on the left and right side of each candle, default: 0.1 (10%), max 0.45, min 0.0
@property (nonatomic) CGFloat barSpace;

/// should the candle bars show? when false, only "ticks" will show
///
/// <em>default</em>: true
@property (nonatomic) BOOL showCandleBar;

/// the width of the candle-shadow-line in pixels.
///
/// <em>default</em>: 3.0
@property (nonatomic) CGFloat shadowWidth;

/// the color of the shadow line
@property (nonatomic, strong) UIColor * _Nullable shadowColor;

/// use candle color for the shadow
@property (nonatomic) BOOL shadowColorSameAsCandle;

/// Is the shadow color same as the candle color?
@property (nonatomic, readonly) BOOL isShadowColorSameAsCandle;

/// color for open == close
@property (nonatomic, strong) UIColor * _Nullable neutralColor;

/// color for open > close
@property (nonatomic, strong) UIColor * _Nullable increasingColor;

/// color for open < close
@property (nonatomic, strong) UIColor * _Nullable decreasingColor;

/// Are increasing values drawn as filled?
@property (nonatomic) BOOL increasingFilled;

/// Are increasing values drawn as filled?
@property (nonatomic, readonly) BOOL isIncreasingFilled;

/// Are decreasing values drawn as filled?
@property (nonatomic) BOOL decreasingFilled;

/// Are decreasing values drawn as filled?
@property (nonatomic, readonly) BOOL isDecreasingFilled;
@end


SWIFT_CLASS("_TtC6Charts34LineScatterCandleRadarChartDataSet")
@interface LineScatterCandleRadarChartDataSet : BarLineScatterCandleBubbleChartDataSet <ILineScatterCandleRadarChartDataSet>

/// Enables / disables the horizontal highlight-indicator. If disabled, the indicator is not drawn.
@property (nonatomic) BOOL drawHorizontalHighlightIndicatorEnabled;

/// Enables / disables the vertical highlight-indicator. If disabled, the indicator is not drawn.
@property (nonatomic) BOOL drawVerticalHighlightIndicatorEnabled;

/// \returns  true if horizontal highlight indicator lines are enabled (drawn)
@property (nonatomic, readonly) BOOL isHorizontalHighlightIndicatorEnabled;

/// \returns  true if vertical highlight indicator lines are enabled (drawn)
@property (nonatomic, readonly) BOOL isVerticalHighlightIndicatorEnabled;

/// Enables / disables both vertical and horizontal highlight-indicators. :param: enabled
- (void)setDrawHighlightIndicators:(BOOL)enabled;
- (id _Nonnull)copyWithZone:(struct _NSZone * _Null_unspecified)zone;
- (nonnull instancetype)init OBJC_DESIGNATED_INITIALIZER;
- (nonnull instancetype)initWithLabel:(NSString * _Nullable)label OBJC_DESIGNATED_INITIALIZER;
- (nonnull instancetype)initWithYVals:(NSArray<ChartDataEntry *> * _Nullable)yVals label:(NSString * _Nullable)label OBJC_DESIGNATED_INITIALIZER;
@end


SWIFT_CLASS("_TtC6Charts18CandleChartDataSet")
@interface CandleChartDataSet : LineScatterCandleRadarChartDataSet <ICandleChartDataSet>
- (nonnull instancetype)init OBJC_DESIGNATED_INITIALIZER;
- (nonnull instancetype)initWithYVals:(NSArray<ChartDataEntry *> * _Nullable)yVals label:(NSString * _Nullable)label OBJC_DESIGNATED_INITIALIZER;
- (void)calcMinMaxWithStart:(NSInteger)start end:(NSInteger)end;

/// the space that is left out on the left and right side of each candle, default: 0.1 (10%), max 0.45, min 0.0
@property (nonatomic) CGFloat barSpace;

/// should the candle bars show? when false, only "ticks" will show
///
/// <em>default</em>: true
@property (nonatomic) BOOL showCandleBar;

/// the width of the candle-shadow-line in pixels.
///
/// <em>default</em>: 1.5
@property (nonatomic) CGFloat shadowWidth;

/// the color of the shadow line
@property (nonatomic, strong) UIColor * _Nullable shadowColor;

/// use candle color for the shadow
@property (nonatomic) BOOL shadowColorSameAsCandle;

/// Is the shadow color same as the candle color?
@property (nonatomic, readonly) BOOL isShadowColorSameAsCandle;

/// color for open == close
@property (nonatomic, strong) UIColor * _Nullable neutralColor;

/// color for open > close
@property (nonatomic, strong) UIColor * _Nullable increasingColor;

/// color for open < close
@property (nonatomic, strong) UIColor * _Nullable decreasingColor;

/// Are increasing values drawn as filled? increasing candlesticks are traditionally hollow
@property (nonatomic) BOOL increasingFilled;

/// Are increasing values drawn as filled?
@property (nonatomic, readonly) BOOL isIncreasingFilled;

/// Are decreasing values drawn as filled? descreasing candlesticks are traditionally filled
@property (nonatomic) BOOL decreasingFilled;

/// Are decreasing values drawn as filled?
@property (nonatomic, readonly) BOOL isDecreasingFilled;
@end


SWIFT_CLASS("_TtC6Charts35LineScatterCandleRadarChartRenderer")
@interface LineScatterCandleRadarChartRenderer : ChartDataRendererBase
- (nonnull instancetype)initWithAnimator:(ChartAnimator * _Nullable)animator viewPortHandler:(ChartViewPortHandler * _Nonnull)viewPortHandler OBJC_DESIGNATED_INITIALIZER;

/// Draws vertical & horizontal highlight-lines if enabled. :param: context :param: points :param: horizontal :param: vertical
- (void)drawHighlightLinesWithContext:(CGContextRef _Nonnull)context point:(CGPoint)point set:(id <ILineScatterCandleRadarChartDataSet> _Nonnull)set;
@end


SWIFT_CLASS("_TtC6Charts24CandleStickChartRenderer")
@interface CandleStickChartRenderer : LineScatterCandleRadarChartRenderer
@property (nonatomic, weak) id <CandleChartDataProvider> _Nullable dataProvider;
- (nonnull instancetype)initWithDataProvider:(id <CandleChartDataProvider> _Nullable)dataProvider animator:(ChartAnimator * _Nullable)animator viewPortHandler:(ChartViewPortHandler * _Nonnull)viewPortHandler OBJC_DESIGNATED_INITIALIZER;
- (void)drawDataWithContext:(CGContextRef _Nonnull)context;
- (void)drawDataSetWithContext:(CGContextRef _Nonnull)context dataSet:(id <ICandleChartDataSet> _Nonnull)dataSet;
- (void)drawValuesWithContext:(CGContextRef _Nonnull)context;
- (void)drawExtrasWithContext:(CGContextRef _Nonnull)context;
- (void)drawHighlightedWithContext:(CGContextRef _Nonnull)context indices:(NSArray<ChartHighlight *> * _Nonnull)indices;
@end



/// Financial chart type that draws candle-sticks.
SWIFT_CLASS("_TtC6Charts20CandleStickChartView")
@interface CandleStickChartView : BarLineChartViewBase <CandleChartDataProvider>
@property (nonatomic, readonly, strong) CandleChartData * _Nullable candleData;
- (nonnull instancetype)initWithFrame:(CGRect)frame OBJC_DESIGNATED_INITIALIZER;
- (nullable instancetype)initWithCoder:(NSCoder * _Nonnull)aDecoder OBJC_DESIGNATED_INITIALIZER;
@end


SWIFT_CLASS("_TtC6Charts13ChartAnimator")
@interface ChartAnimator : NSObject
@property (nonatomic, weak) id <ChartAnimatorDelegate> _Nullable delegate;
@property (nonatomic, copy) void (^ _Nullable updateBlock)(void);
@property (nonatomic, copy) void (^ _Nullable stopBlock)(void);

/// the phase that is animated and influences the drawn values on the x-axis
@property (nonatomic) CGFloat phaseX;

/// the phase that is animated and influences the drawn values on the y-axis
@property (nonatomic) CGFloat phaseY;
- (nonnull instancetype)init OBJC_DESIGNATED_INITIALIZER;
- (void)stop;

/// Animates the drawing / rendering of the chart on both x- and y-axis with the specified animation time. If animate(...) is called, no further calling of invalidate() is necessary to refresh the chart.
///
/// \param xAxisDuration duration for animating the x axis
///
/// \param yAxisDuration duration for animating the y axis
///
/// \param easingX an easing function for the animation on the x axis
///
/// \param easingY an easing function for the animation on the y axis
- (void)animateWithXAxisDuration:(NSTimeInterval)xAxisDuration yAxisDuration:(NSTimeInterval)yAxisDuration easingX:(CGFloat (^ _Nullable)(NSTimeInterval elapsed, NSTimeInterval duration))easingX easingY:(CGFloat (^ _Nullable)(NSTimeInterval elapsed, NSTimeInterval duration))easingY;

/// Animates the drawing / rendering of the chart on both x- and y-axis with the specified animation time. If animate(...) is called, no further calling of invalidate() is necessary to refresh the chart.
///
/// \param xAxisDuration duration for animating the x axis
///
/// \param yAxisDuration duration for animating the y axis
///
/// \param easingOptionX the easing function for the animation on the x axis
///
/// \param easingOptionY the easing function for the animation on the y axis
- (void)animateWithXAxisDuration:(NSTimeInterval)xAxisDuration yAxisDuration:(NSTimeInterval)yAxisDuration easingOptionX:(enum ChartEasingOption)easingOptionX easingOptionY:(enum ChartEasingOption)easingOptionY;

/// Animates the drawing / rendering of the chart on both x- and y-axis with the specified animation time. If animate(...) is called, no further calling of invalidate() is necessary to refresh the chart.
///
/// \param xAxisDuration duration for animating the x axis
///
/// \param yAxisDuration duration for animating the y axis
///
/// \param easing an easing function for the animation
- (void)animateWithXAxisDuration:(NSTimeInterval)xAxisDuration yAxisDuration:(NSTimeInterval)yAxisDuration easing:(CGFloat (^ _Nullable)(NSTimeInterval elapsed, NSTimeInterval duration))easing;

/// Animates the drawing / rendering of the chart on both x- and y-axis with the specified animation time. If animate(...) is called, no further calling of invalidate() is necessary to refresh the chart.
///
/// \param xAxisDuration duration for animating the x axis
///
/// \param yAxisDuration duration for animating the y axis
///
/// \param easingOption the easing function for the animation
- (void)animateWithXAxisDuration:(NSTimeInterval)xAxisDuration yAxisDuration:(NSTimeInterval)yAxisDuration easingOption:(enum ChartEasingOption)easingOption;

/// Animates the drawing / rendering of the chart on both x- and y-axis with the specified animation time. If animate(...) is called, no further calling of invalidate() is necessary to refresh the chart.
///
/// \param xAxisDuration duration for animating the x axis
///
/// \param yAxisDuration duration for animating the y axis
- (void)animateWithXAxisDuration:(NSTimeInterval)xAxisDuration yAxisDuration:(NSTimeInterval)yAxisDuration;

/// Animates the drawing / rendering of the chart the x-axis with the specified animation time. If animate(...) is called, no further calling of invalidate() is necessary to refresh the chart.
///
/// \param xAxisDuration duration for animating the x axis
///
/// \param easing an easing function for the animation
- (void)animateWithXAxisDuration:(NSTimeInterval)xAxisDuration easing:(CGFloat (^ _Nullable)(NSTimeInterval elapsed, NSTimeInterval duration))easing;

/// Animates the drawing / rendering of the chart the x-axis with the specified animation time. If animate(...) is called, no further calling of invalidate() is necessary to refresh the chart.
///
/// \param xAxisDuration duration for animating the x axis
///
/// \param easingOption the easing function for the animation
- (void)animateWithXAxisDuration:(NSTimeInterval)xAxisDuration easingOption:(enum ChartEasingOption)easingOption;

/// Animates the drawing / rendering of the chart the x-axis with the specified animation time. If animate(...) is called, no further calling of invalidate() is necessary to refresh the chart.
///
/// \param xAxisDuration duration for animating the x axis
- (void)animateWithXAxisDuration:(NSTimeInterval)xAxisDuration;

/// Animates the drawing / rendering of the chart the y-axis with the specified animation time. If animate(...) is called, no further calling of invalidate() is necessary to refresh the chart.
///
/// \param yAxisDuration duration for animating the y axis
///
/// \param easing an easing function for the animation
- (void)animateWithYAxisDuration:(NSTimeInterval)yAxisDuration easing:(CGFloat (^ _Nullable)(NSTimeInterval elapsed, NSTimeInterval duration))easing;

/// Animates the drawing / rendering of the chart the y-axis with the specified animation time. If animate(...) is called, no further calling of invalidate() is necessary to refresh the chart.
///
/// \param yAxisDuration duration for animating the y axis
///
/// \param easingOption the easing function for the animation
- (void)animateWithYAxisDuration:(NSTimeInterval)yAxisDuration easingOption:(enum ChartEasingOption)easingOption;

/// Animates the drawing / rendering of the chart the y-axis with the specified animation time. If animate(...) is called, no further calling of invalidate() is necessary to refresh the chart.
///
/// \param yAxisDuration duration for animating the y axis
- (void)animateWithYAxisDuration:(NSTimeInterval)yAxisDuration;
@end




/// This class encapsulates everything both Axis, Legend and LimitLines have in common
SWIFT_CLASS("_TtC6Charts18ChartComponentBase")
@interface ChartComponentBase : NSObject

/// flag that indicates if this component is enabled or not
@property (nonatomic) BOOL enabled;

/// Sets the used x-axis offset for the labels on this axis. default: 5.0
@property (nonatomic) CGFloat xOffset;

/// Sets the used y-axis offset for the labels on this axis. default: 5.0 (or 0.0 on ChartYAxis)
@property (nonatomic) CGFloat yOffset;
- (nonnull instancetype)init OBJC_DESIGNATED_INITIALIZER;
@property (nonatomic, readonly) BOOL isEnabled;
@end

@class ChartLimitLine;


/// Base class for all axes
SWIFT_CLASS("_TtC6Charts13ChartAxisBase")
@interface ChartAxisBase : ChartComponentBase
@property (nonatomic, strong) UIFont * _Nonnull labelFont;
@property (nonatomic, strong) UIColor * _Nonnull labelTextColor;
@property (nonatomic, strong) UIColor * _Nonnull axisLineColor;
@property (nonatomic) CGFloat axisLineWidth;
@property (nonatomic) CGFloat axisLineDashPhase;
@property (nonatomic, copy) NSArray<NSNumber *> * _Null_unspecified axisLineDashLengths;
@property (nonatomic, strong) UIColor * _Nonnull gridColor;
@property (nonatomic) CGFloat gridLineWidth;
@property (nonatomic) CGFloat gridLineDashPhase;
@property (nonatomic, copy) NSArray<NSNumber *> * _Null_unspecified gridLineDashLengths;
@property (nonatomic) CGLineCap gridLineCap;
@property (nonatomic) BOOL drawGridLinesEnabled;
@property (nonatomic) BOOL drawAxisLineEnabled;

/// flag that indicates of the labels of this axis should be drawn or not
@property (nonatomic) BOOL drawLabelsEnabled;

/// Are the LimitLines drawn behind the data or in front of the data?
///
/// <em>default</em>: false
@property (nonatomic) BOOL drawLimitLinesBehindDataEnabled;

/// the flag can be used to turn off the antialias for grid lines
@property (nonatomic) BOOL gridAntialiasEnabled;
- (nonnull instancetype)init OBJC_DESIGNATED_INITIALIZER;
- (NSString * _Nonnull)getLongestLabel;
@property (nonatomic, readonly) BOOL isDrawGridLinesEnabled;
@property (nonatomic, readonly) BOOL isDrawAxisLineEnabled;
@property (nonatomic, readonly) BOOL isDrawLabelsEnabled;

/// Are the LimitLines drawn behind the data or in front of the data?
///
/// <em>default</em>: false
@property (nonatomic, readonly) BOOL isDrawLimitLinesBehindDataEnabled;

/// Do not touch this directly, instead, use axisMinValue. This is automatically calculated to represent the real min value, and is used when calculating the effective minimum.
@property (nonatomic) double _axisMinimum;

/// Do not touch this directly, instead, use axisMaxValue. This is automatically calculated to represent the real max value, and is used when calculating the effective maximum.
@property (nonatomic) double _axisMaximum;

/// the total range of values this axis covers
@property (nonatomic) double axisRange;

/// Adds a new ChartLimitLine to this axis.
- (void)addLimitLine:(ChartLimitLine * _Nonnull)line;

/// Removes the specified ChartLimitLine from the axis.
- (void)removeLimitLine:(ChartLimitLine * _Nonnull)line;

/// Removes all LimitLines from the axis.
- (void)removeAllLimitLines;

/// \returns  the LimitLines of this axis.
@property (nonatomic, readonly, copy) NSArray<ChartLimitLine *> * _Nonnull limitLines;

/// By calling this method, any custom minimum value that has been previously set is reseted, and the calculation is done automatically.
- (void)resetCustomAxisMin;
@property (nonatomic, readonly) BOOL isAxisMinCustom;

/// By calling this method, any custom maximum value that has been previously set is reseted, and the calculation is done automatically.
- (void)resetCustomAxisMax;
@property (nonatomic, readonly) BOOL isAxisMaxCustom;

/// The minimum value for this axis. If set, this value will not be calculated automatically depending on the provided data. Use resetCustomAxisMin() to undo this.
@property (nonatomic) double axisMinValue;

/// The maximum value for this axis. If set, this value will not be calculated automatically depending on the provided data. Use resetCustomAxisMin() to undo this.
@property (nonatomic) double axisMaxValue;
@end


SWIFT_CLASS("_TtC6Charts21ChartAxisRendererBase")
@interface ChartAxisRendererBase : ChartRendererBase
@property (nonatomic, strong) ChartTransformer * _Null_unspecified transformer;
- (nonnull instancetype)init OBJC_DESIGNATED_INITIALIZER;
- (nonnull instancetype)initWithViewPortHandler:(ChartViewPortHandler * _Nonnull)viewPortHandler transformer:(ChartTransformer * _Null_unspecified)transformer OBJC_DESIGNATED_INITIALIZER;

/// Draws the axis labels on the specified context
- (void)renderAxisLabelsWithContext:(CGContextRef _Nonnull)context;

/// Draws the grid lines belonging to the axis.
- (void)renderGridLinesWithContext:(CGContextRef _Nonnull)context;

/// Draws the line that goes alongside the axis.
- (void)renderAxisLineWithContext:(CGContextRef _Nonnull)context;

/// Draws the LimitLines associated with this axis to the screen.
- (void)renderLimitLinesWithContext:(CGContextRef _Nonnull)context;
@end



SWIFT_CLASS("_TtC6Charts19ChartColorTemplates")
@interface ChartColorTemplates : NSObject
+ (NSArray<UIColor *> * _Nonnull)liberty;
+ (NSArray<UIColor *> * _Nonnull)joyful;
+ (NSArray<UIColor *> * _Nonnull)pastel;
+ (NSArray<UIColor *> * _Nonnull)colorful;
+ (NSArray<UIColor *> * _Nonnull)vordiplom;
+ (NSArray<UIColor *> * _Nonnull)material;
+ (UIColor * _Nonnull)colorFromString:(NSString * _Nonnull)colorString;
- (nonnull instancetype)init OBJC_DESIGNATED_INITIALIZER;
@end




SWIFT_CLASS("_TtC6Charts19ChartDataBaseFilter")
@interface ChartDataBaseFilter : NSObject
- (nonnull instancetype)init OBJC_DESIGNATED_INITIALIZER;
- (NSArray<ChartDataEntry *> * _Nonnull)filter:(NSArray<ChartDataEntry *> * _Nonnull)points;
@end

enum ApproximatorType : NSInteger;

SWIFT_CLASS("_TtC6Charts27ChartDataApproximatorFilter")
@interface ChartDataApproximatorFilter : ChartDataBaseFilter

/// the type of filtering algorithm to use
@property (nonatomic) enum ApproximatorType type;

/// the tolerance to be filtered with When using the Douglas-Peucker-Algorithm, the tolerance is an angle in degrees, that will trigger the filtering
@property (nonatomic) double tolerance;
@property (nonatomic) double scaleRatio;
@property (nonatomic) double deltaRatio;
- (nonnull instancetype)init OBJC_DESIGNATED_INITIALIZER;

/// Initializes the approximator with the given type and tolerance. If toleranec <= 0, no filtering will be done.
- (nonnull instancetype)initWithType:(enum ApproximatorType)type tolerance:(double)tolerance OBJC_DESIGNATED_INITIALIZER;

/// Sets type and tolerance. If tolerance <= 0, no filtering will be done.
- (void)setup:(enum ApproximatorType)type tolerance:(double)tolerance;

/// Sets the ratios for x- and y-axis, as well as the ratio of the scale levels
- (void)setRatios:(double)deltaRatio scaleRatio:(double)scaleRatio;

/// Filters according to type. Uses the pre set set tolerance
///
/// \param points the points to filter
- (NSArray<ChartDataEntry *> * _Nonnull)filter:(NSArray<ChartDataEntry *> * _Nonnull)points;

/// Filters according to type.
///
/// \param points the points to filter
///
/// \param tolerance the angle in degrees that will trigger the filtering
- (NSArray<ChartDataEntry *> * _Nonnull)filter:(NSArray<ChartDataEntry *> * _Nonnull)points tolerance:(double)tolerance;
@end

typedef SWIFT_ENUM(NSInteger, ApproximatorType) {
  ApproximatorTypeNone = 0,
  ApproximatorTypeRamerDouglasPeucker = 1,
};






typedef SWIFT_ENUM(NSInteger, ChartDataSetRounding) {
  ChartDataSetRoundingUp = 0,
  ChartDataSetRoundingDown = 1,
  ChartDataSetRoundingClosest = 2,
};

@protocol ILineChartDataSet;
@protocol LineChartDataProvider;


/// Protocol for providing a custom logic to where the filling line of a LineDataSet should end. This of course only works if setFillEnabled(...) is set to true.
SWIFT_PROTOCOL("_TtP6Charts18ChartFillFormatter_")
@protocol ChartFillFormatter

/// \returns  the vertical (y-axis) position where the filled-line of the LineDataSet should end.
- (CGFloat)getFillLinePositionWithDataSet:(id <ILineChartDataSet> _Nonnull)dataSet dataProvider:(id <LineChartDataProvider> _Nonnull)dataProvider;
@end



/// Default formatter that calculates the position of the filled line.
SWIFT_CLASS("_TtC6Charts25ChartDefaultFillFormatter")
@interface ChartDefaultFillFormatter : NSObject <ChartFillFormatter>
- (nonnull instancetype)init OBJC_DESIGNATED_INITIALIZER;
- (CGFloat)getFillLinePositionWithDataSet:(id <ILineChartDataSet> _Nonnull)dataSet dataProvider:(id <LineChartDataProvider> _Nonnull)dataProvider;
@end



/// An interface for providing custom x-axis Strings.
SWIFT_PROTOCOL("_TtP6Charts24ChartXAxisValueFormatter_")
@protocol ChartXAxisValueFormatter

/// For performance reasons, avoid excessive calculations and memory allocations inside this method.
///
/// \param index the x-index that is currently being drawn
///
/// \param original the original x-axis label to be drawn
///
/// \param viewPortHandler provides information about the current chart state (scale, translation, ...)
///
/// \returns  the customized label that is drawn on the x-axis.
- (NSString * _Nonnull)stringForXValue:(NSInteger)index original:(NSString * _Nonnull)original viewPortHandler:(ChartViewPortHandler * _Nonnull)viewPortHandler;
@end



/// An interface for providing custom x-axis Strings.
SWIFT_CLASS("_TtC6Charts31ChartDefaultXAxisValueFormatter")
@interface ChartDefaultXAxisValueFormatter : NSObject <ChartXAxisValueFormatter>
- (NSString * _Nonnull)stringForXValue:(NSInteger)index original:(NSString * _Nonnull)original viewPortHandler:(ChartViewPortHandler * _Nonnull)viewPortHandler;
- (nonnull instancetype)init OBJC_DESIGNATED_INITIALIZER;
@end

typedef SWIFT_ENUM(NSInteger, ChartEasingOption) {
  ChartEasingOptionLinear = 0,
  ChartEasingOptionEaseInQuad = 1,
  ChartEasingOptionEaseOutQuad = 2,
  ChartEasingOptionEaseInOutQuad = 3,
  ChartEasingOptionEaseInCubic = 4,
  ChartEasingOptionEaseOutCubic = 5,
  ChartEasingOptionEaseInOutCubic = 6,
  ChartEasingOptionEaseInQuart = 7,
  ChartEasingOptionEaseOutQuart = 8,
  ChartEasingOptionEaseInOutQuart = 9,
  ChartEasingOptionEaseInQuint = 10,
  ChartEasingOptionEaseOutQuint = 11,
  ChartEasingOptionEaseInOutQuint = 12,
  ChartEasingOptionEaseInSine = 13,
  ChartEasingOptionEaseOutSine = 14,
  ChartEasingOptionEaseInOutSine = 15,
  ChartEasingOptionEaseInExpo = 16,
  ChartEasingOptionEaseOutExpo = 17,
  ChartEasingOptionEaseInOutExpo = 18,
  ChartEasingOptionEaseInCirc = 19,
  ChartEasingOptionEaseOutCirc = 20,
  ChartEasingOptionEaseInOutCirc = 21,
  ChartEasingOptionEaseInElastic = 22,
  ChartEasingOptionEaseOutElastic = 23,
  ChartEasingOptionEaseInOutElastic = 24,
  ChartEasingOptionEaseInBack = 25,
  ChartEasingOptionEaseOutBack = 26,
  ChartEasingOptionEaseInOutBack = 27,
  ChartEasingOptionEaseInBounce = 28,
  ChartEasingOptionEaseOutBounce = 29,
  ChartEasingOptionEaseInOutBounce = 30,
};

enum ChartFillType : NSInteger;

SWIFT_CLASS("_TtC6Charts9ChartFill")
@interface ChartFill : NSObject
@property (nonatomic, readonly) enum ChartFillType type;
@property (nonatomic, readonly) CGColorRef _Nullable color;
@property (nonatomic, readonly) CGGradientRef _Nullable gradient;
@property (nonatomic, readonly) CGFloat gradientAngle;
@property (nonatomic, readonly) CGPoint gradientStartOffsetPercent;
@property (nonatomic, readonly) CGFloat gradientStartRadiusPercent;
@property (nonatomic, readonly) CGPoint gradientEndOffsetPercent;
@property (nonatomic, readonly) CGFloat gradientEndRadiusPercent;
@property (nonatomic, readonly) CGImageRef _Nullable image;
@property (nonatomic, readonly) CGLayerRef _Nullable layer;
- (nonnull instancetype)init OBJC_DESIGNATED_INITIALIZER;
- (nonnull instancetype)initWithCGColor:(CGColorRef _Nonnull)CGColor OBJC_DESIGNATED_INITIALIZER;
- (nonnull instancetype)initWithColor:(UIColor * _Nonnull)color;
- (nonnull instancetype)initWithLinearGradient:(CGGradientRef _Nonnull)linearGradient angle:(CGFloat)angle OBJC_DESIGNATED_INITIALIZER;
- (nonnull instancetype)initWithRadialGradient:(CGGradientRef _Nonnull)radialGradient startOffsetPercent:(CGPoint)startOffsetPercent startRadiusPercent:(CGFloat)startRadiusPercent endOffsetPercent:(CGPoint)endOffsetPercent endRadiusPercent:(CGFloat)endRadiusPercent OBJC_DESIGNATED_INITIALIZER;
- (nonnull instancetype)initWithRadialGradient:(CGGradientRef _Nonnull)radialGradient;
- (nonnull instancetype)initWithCGImage:(CGImageRef _Nonnull)CGImage tiled:(BOOL)tiled OBJC_DESIGNATED_INITIALIZER;
- (nonnull instancetype)initWithImage:(UIImage * _Nonnull)image tiled:(BOOL)tiled;
- (nonnull instancetype)initWithCGImage:(CGImageRef _Nonnull)CGImage;
- (nonnull instancetype)initWithImage:(UIImage * _Nonnull)image;
- (nonnull instancetype)initWithCGLayer:(CGLayerRef _Nonnull)CGLayer OBJC_DESIGNATED_INITIALIZER;
+ (ChartFill * _Nonnull)fillWithCGColor:(CGColorRef _Nonnull)CGColor;
+ (ChartFill * _Nonnull)fillWithColor:(UIColor * _Nonnull)color;
+ (ChartFill * _Nonnull)fillWithLinearGradient:(CGGradientRef _Nonnull)linearGradient angle:(CGFloat)angle;
+ (ChartFill * _Nonnull)fillWithRadialGradient:(CGGradientRef _Nonnull)radialGradient startOffsetPercent:(CGPoint)startOffsetPercent startRadiusPercent:(CGFloat)startRadiusPercent endOffsetPercent:(CGPoint)endOffsetPercent endRadiusPercent:(CGFloat)endRadiusPercent;
+ (ChartFill * _Nonnull)fillWithRadialGradient:(CGGradientRef _Nonnull)radialGradient;
+ (ChartFill * _Nonnull)fillWithCGImage:(CGImageRef _Nonnull)CGImage tiled:(BOOL)tiled;
+ (ChartFill * _Nonnull)fillWithImage:(UIImage * _Nonnull)image tiled:(BOOL)tiled;
+ (ChartFill * _Nonnull)fillWithCGImage:(CGImageRef _Nonnull)CGImage;
+ (ChartFill * _Nonnull)fillWithImage:(UIImage * _Nonnull)image;
+ (ChartFill * _Nonnull)fillWithCGLayer:(CGLayerRef _Nonnull)CGLayer;

/// Draws the provided path in filled mode with the provided area
- (void)fillPathWithContext:(CGContextRef _Nonnull)context rect:(CGRect)rect;
@end

typedef SWIFT_ENUM_NAMED(NSInteger, ChartFillType, "Type") {
  ChartFillTypeEmpty = 0,
  ChartFillTypeColor = 1,
  ChartFillTypeLinearGradient = 2,
  ChartFillTypeRadialGradient = 3,
  ChartFillTypeImage = 4,
  ChartFillTypeTiledImage = 5,
  ChartFillTypeLayer = 6,
};



SWIFT_CLASS("_TtC6Charts14ChartHighlight")
@interface ChartHighlight : NSObject
- (nonnull instancetype)init OBJC_DESIGNATED_INITIALIZER;

/// \param xIndex the index of the highlighted value on the x-axis
///
/// \param value the y-value of the highlighted value
///
/// \param dataIndex the index of the Data the highlighted value belongs to
///
/// \param dataSetIndex the index of the DataSet the highlighted value belongs to
///
/// \param stackIndex references which value of a stacked-bar entry has been selected
///
/// \param range the range the selected stack-value is in
- (nonnull instancetype)initWithXIndex:(NSInteger)x value:(double)value dataIndex:(NSInteger)dataIndex dataSetIndex:(NSInteger)dataSetIndex stackIndex:(NSInteger)stackIndex range:(ChartRange * _Nullable)range OBJC_DESIGNATED_INITIALIZER;

/// \param xIndex the index of the highlighted value on the x-axis
///
/// \param value the y-value of the highlighted value
///
/// \param dataIndex the index of the Data the highlighted value belongs to
///
/// \param dataSetIndex the index of the DataSet the highlighted value belongs to
///
/// \param stackIndex references which value of a stacked-bar entry has been selected
- (nonnull instancetype)initWithXIndex:(NSInteger)x value:(double)value dataIndex:(NSInteger)dataIndex dataSetIndex:(NSInteger)dataSetIndex stackIndex:(NSInteger)stackIndex;

/// \param xIndex the index of the highlighted value on the x-axis
///
/// \param value the y-value of the highlighted value
///
/// \param dataSetIndex the index of the DataSet the highlighted value belongs to
///
/// \param stackIndex references which value of a stacked-bar entry has been selected
///
/// \param range the range the selected stack-value is in
- (nonnull instancetype)initWithXIndex:(NSInteger)x value:(double)value dataSetIndex:(NSInteger)dataSetIndex stackIndex:(NSInteger)stackIndex range:(ChartRange * _Nullable)range;

/// \param xIndex the index of the highlighted value on the x-axis
///
/// \param value the y-value of the highlighted value
///
/// \param dataSetIndex the index of the DataSet the highlighted value belongs to
///
/// \param stackIndex references which value of a stacked-bar entry has been selected
///
/// \param range the range the selected stack-value is in
- (nonnull instancetype)initWithXIndex:(NSInteger)x value:(double)value dataSetIndex:(NSInteger)dataSetIndex stackIndex:(NSInteger)stackIndex;

/// \param xIndex the index of the highlighted value on the x-axis
///
/// \param dataSetIndex the index of the DataSet the highlighted value belongs to
///
/// \param stackIndex references which value of a stacked-bar entry has been selected
- (nonnull instancetype)initWithXIndex:(NSInteger)x dataSetIndex:(NSInteger)dataSetIndex stackIndex:(NSInteger)stackIndex;

/// \param xIndex the index of the highlighted value on the x-axis
///
/// \param dataSetIndex the index of the DataSet the highlighted value belongs to
- (nonnull instancetype)initWithXIndex:(NSInteger)x dataSetIndex:(NSInteger)dataSetIndex;
@property (nonatomic, readonly) NSInteger xIndex;
@property (nonatomic, readonly) double value;
@property (nonatomic, readonly) NSInteger dataIndex;
@property (nonatomic, readonly) NSInteger dataSetIndex;
@property (nonatomic, readonly) NSInteger stackIndex;

/// \returns  the range of values the selected value of a stacked bar is in. (this is only relevant for stacked-barchart)
@property (nonatomic, readonly, strong) ChartRange * _Nullable range;
@property (nonatomic, readonly, copy) NSString * _Nonnull description;
- (BOOL)isEqual:(id _Nullable)object;
@end


enum ChartLegendPosition : NSInteger;
enum ChartLegendHorizontalAlignment : NSInteger;
enum ChartLegendVerticalAlignment : NSInteger;
enum ChartLegendOrientation : NSInteger;
enum ChartLegendDirection : NSInteger;
enum ChartLegendForm : NSInteger;

SWIFT_CLASS("_TtC6Charts11ChartLegend")
@interface ChartLegend : ChartComponentBase

/// This property is deprecated - Use position, horizontalAlignment, verticalAlignment, orientation, drawInside, direction.
@property (nonatomic) enum ChartLegendPosition position;

/// The horizontal alignment of the legend
@property (nonatomic) enum ChartLegendHorizontalAlignment horizontalAlignment;

/// The vertical alignment of the legend
@property (nonatomic) enum ChartLegendVerticalAlignment verticalAlignment;

/// The orientation of the legend
@property (nonatomic) enum ChartLegendOrientation orientation;

/// Flag indicating whether the legend will draw inside the chart or outside
@property (nonatomic) BOOL drawInside;

/// Flag indicating whether the legend will draw inside the chart or outside
@property (nonatomic, readonly) BOOL isDrawInsideEnabled;

/// The text direction of the legend
@property (nonatomic) enum ChartLegendDirection direction;
@property (nonatomic, strong) UIFont * _Nonnull font;
@property (nonatomic, strong) UIColor * _Nonnull textColor;
@property (nonatomic) enum ChartLegendForm form;
@property (nonatomic) CGFloat formSize;
@property (nonatomic) CGFloat formLineWidth;
@property (nonatomic) CGFloat xEntrySpace;
@property (nonatomic) CGFloat yEntrySpace;
@property (nonatomic) CGFloat formToTextSpace;
@property (nonatomic) CGFloat stackSpace;
@property (nonatomic, copy) NSArray<NSNumber *> * _Nonnull calculatedLabelBreakPoints;
- (nonnull instancetype)init OBJC_DESIGNATED_INITIALIZER;
- (nonnull instancetype)initWithColors:(NSArray<NSObject *> * _Nonnull)colors labels:(NSArray<NSObject *> * _Nonnull)labels OBJC_DESIGNATED_INITIALIZER;
- (CGSize)getMaximumEntrySize:(UIFont * _Nonnull)font;
- (NSString * _Nullable)getLabel:(NSInteger)index;

/// This function is deprecated - Please read neededWidth/neededHeight after calculateDimensions was called.
- (CGSize)getFullSize:(UIFont * _Nonnull)labelFont;
@property (nonatomic) CGFloat neededWidth;
@property (nonatomic) CGFloat neededHeight;
@property (nonatomic) CGFloat textWidthMax;
@property (nonatomic) CGFloat textHeightMax;

/// flag that indicates if word wrapping is enabled this is currently supported only for orientation == Horizontal. you may want to set maxSizePercent when word wrapping, to set the point where the text wraps.
///
/// <em>default</em>: false
@property (nonatomic) BOOL wordWrapEnabled;

/// if this is set, then word wrapping the legend is enabled.
@property (nonatomic, readonly) BOOL isWordWrapEnabled;

/// The maximum relative size out of the whole chart view in percent. If the legend is to the right/left of the chart, then this affects the width of the legend. If the legend is to the top/bottom of the chart, then this affects the height of the legend.
///
/// <em>default</em>: 0.95 (95%)
@property (nonatomic) CGFloat maxSizePercent;
- (void)calculateDimensionsWithLabelFont:(UIFont * _Nonnull)labelFont viewPortHandler:(ChartViewPortHandler * _Nonnull)viewPortHandler;

/// Calling this will disable the custom legend labels (set by setLegend(...)). Instead, the labels will again be calculated automatically (after notifyDataSetChanged() is called).
- (void)resetCustom;

/// default: false (automatic legend)
///
/// \returns  true if a custom legend labels and colors has been set
@property (nonatomic, readonly) BOOL isLegendCustom;

/// MARK: - ObjC compatibility colors that will be appended to the end of the colors array after calculating the legend.
@property (nonatomic, readonly, copy) NSArray<NSObject *> * _Nonnull extraColorsObjc;

/// labels that will be appended to the end of the labels array after calculating the legend. a nil label will start a group.
@property (nonatomic, readonly, copy) NSArray<NSObject *> * _Nonnull extraLabelsObjc;

/// the legend colors array, each color is for the form drawn at the same index (ObjC bridging functions, as Swift 1.2 does not bridge optionals in array to NSNulls)
@property (nonatomic, copy) NSArray<NSObject *> * _Nonnull colorsObjc;

/// (ObjC bridging functions, as Swift 1.2 does not bridge optionals in array to NSNulls)
@property (nonatomic, copy) NSArray<NSObject *> * _Nonnull labelsObjc;

/// colors and labels that will be appended to the end of the auto calculated colors and labels after calculating the legend. (if the legend has already been calculated, you will need to call notifyDataSetChanged() to let the changes take effect)
- (void)setExtraWithColors:(NSArray<NSObject *> * _Nonnull)colors labels:(NSArray<NSObject *> * _Nonnull)labels;

/// Sets a custom legend's labels and colors arrays. The colors count should match the labels count.
///
/// <ul><li>Each color is for the form drawn at the same index.</li><li>A nil label will start a group.</li><li>A nil color will avoid drawing a form, and a clearColor will leave a space for the form.
/// This will disable the feature that automatically calculates the legend labels and colors from the datasets.
/// Call <code>resetLegendToAuto(...)
/// </code> to re-enable automatic calculation, and then if needed - call <code>notifyDataSetChanged()
/// </code> on the chart to make it refresh the data.</li></ul>
- (void)setCustomWithColors:(NSArray<NSObject *> * _Nonnull)colors labels:(NSArray<NSObject *> * _Nonnull)labels;
@end


/// This property is deprecated - Use position, horizontalAlignment, verticalAlignment, orientation, drawInside, direction.
typedef SWIFT_ENUM_NAMED(NSInteger, ChartLegendPosition, "Position") {
  ChartLegendPositionRightOfChart = 0,
  ChartLegendPositionRightOfChartCenter = 1,
  ChartLegendPositionRightOfChartInside = 2,
  ChartLegendPositionLeftOfChart = 3,
  ChartLegendPositionLeftOfChartCenter = 4,
  ChartLegendPositionLeftOfChartInside = 5,
  ChartLegendPositionBelowChartLeft = 6,
  ChartLegendPositionBelowChartRight = 7,
  ChartLegendPositionBelowChartCenter = 8,
  ChartLegendPositionAboveChartLeft = 9,
  ChartLegendPositionAboveChartRight = 10,
  ChartLegendPositionAboveChartCenter = 11,
  ChartLegendPositionPiechartCenter = 12,
};

typedef SWIFT_ENUM_NAMED(NSInteger, ChartLegendForm, "Form") {
  ChartLegendFormSquare = 0,
  ChartLegendFormCircle = 1,
  ChartLegendFormLine = 2,
};

typedef SWIFT_ENUM_NAMED(NSInteger, ChartLegendHorizontalAlignment, "HorizontalAlignment") {
  ChartLegendHorizontalAlignmentLeft = 0,
  ChartLegendHorizontalAlignmentCenter = 1,
  ChartLegendHorizontalAlignmentRight = 2,
};

typedef SWIFT_ENUM_NAMED(NSInteger, ChartLegendVerticalAlignment, "VerticalAlignment") {
  ChartLegendVerticalAlignmentTop = 0,
  ChartLegendVerticalAlignmentCenter = 1,
  ChartLegendVerticalAlignmentBottom = 2,
};

typedef SWIFT_ENUM_NAMED(NSInteger, ChartLegendOrientation, "Orientation") {
  ChartLegendOrientationHorizontal = 0,
  ChartLegendOrientationVertical = 1,
};

typedef SWIFT_ENUM_NAMED(NSInteger, ChartLegendDirection, "Direction") {
  ChartLegendDirectionLeftToRight = 0,
  ChartLegendDirectionRightToLeft = 1,
};


SWIFT_CLASS("_TtC6Charts19ChartLegendRenderer")
@interface ChartLegendRenderer : ChartRendererBase

/// the legend object this renderer renders
@property (nonatomic, strong) ChartLegend * _Nullable legend;
- (nonnull instancetype)initWithViewPortHandler:(ChartViewPortHandler * _Nonnull)viewPortHandler legend:(ChartLegend * _Nullable)legend OBJC_DESIGNATED_INITIALIZER;

/// Prepares the legend and calculates all needed forms, labels and colors.
- (void)computeLegend:(ChartData * _Nonnull)data;
- (void)renderLegendWithContext:(CGContextRef _Nonnull)context;

/// Draws the Legend-form at the given position with the color at the given index.
- (void)drawFormWithContext:(CGContextRef _Nonnull)context x:(CGFloat)x y:(CGFloat)y colorIndex:(NSInteger)colorIndex legend:(ChartLegend * _Nonnull)legend;

/// Draws the provided label at the given position.
- (void)drawLabelWithContext:(CGContextRef _Nonnull)context x:(CGFloat)x y:(CGFloat)y label:(NSString * _Nonnull)label font:(UIFont * _Nonnull)font textColor:(UIColor * _Nonnull)textColor;
@end

enum ChartLimitLabelPosition : NSInteger;


/// The limit line is an additional feature for all Line, Bar and ScatterCharts. It allows the displaying of an additional line in the chart that marks a certain maximum / limit on the specified axis (x- or y-axis).
SWIFT_CLASS("_TtC6Charts14ChartLimitLine")
@interface ChartLimitLine : ChartComponentBase

/// limit / maximum (the y-value or xIndex)
@property (nonatomic) double limit;
@property (nonatomic, strong) UIColor * _Nonnull lineColor;
@property (nonatomic) CGFloat lineDashPhase;
@property (nonatomic, copy) NSArray<NSNumber *> * _Nullable lineDashLengths;
@property (nonatomic, strong) UIColor * _Nonnull valueTextColor;
@property (nonatomic, strong) UIFont * _Nonnull valueFont;
@property (nonatomic, copy) NSString * _Nonnull label;
@property (nonatomic) BOOL drawLabelEnabled;
@property (nonatomic) enum ChartLimitLabelPosition labelPosition;
- (nonnull instancetype)init OBJC_DESIGNATED_INITIALIZER;
- (nonnull instancetype)initWithLimit:(double)limit OBJC_DESIGNATED_INITIALIZER;
- (nonnull instancetype)initWithLimit:(double)limit label:(NSString * _Nonnull)label OBJC_DESIGNATED_INITIALIZER;

/// set the line width of the chart (min = 0.2, max = 12); default 2
@property (nonatomic) CGFloat lineWidth;
@end

typedef SWIFT_ENUM_NAMED(NSInteger, ChartLimitLabelPosition, "LabelPosition") {
  ChartLimitLabelPositionLeftTop = 0,
  ChartLimitLabelPositionLeftBottom = 1,
  ChartLimitLabelPositionRightTop = 2,
  ChartLimitLabelPositionRightBottom = 3,
};


SWIFT_CLASS("_TtC6Charts11ChartMarker")
@interface ChartMarker : NSObject

/// The marker image to render
@property (nonatomic, strong) UIImage * _Nullable image;
@property (nonatomic, strong) UIView * _Nullable view;
@property (nonatomic, copy) void (^ _Nullable refreshCallback)(ChartDataEntry * _Nonnull entry, ChartHighlight * _Nonnull highlight);

/// Use this to return the desired offset you wish the MarkerView to have on the x-axis.
@property (nonatomic) CGPoint offset;

/// The marker's size
@property (nonatomic, readonly) CGSize size;
- (nonnull instancetype)init OBJC_DESIGNATED_INITIALIZER;
- (nonnull instancetype)initWithView:(UIView * _Nonnull)view OBJC_DESIGNATED_INITIALIZER;
- (nonnull instancetype)initWithView:(UIView * _Nonnull)view refreshCallback:(void (^ _Nonnull)(ChartDataEntry * _Nonnull entry, ChartHighlight * _Nonnull highlight))refreshCallback OBJC_DESIGNATED_INITIALIZER;

/// Returns the offset for drawing at the specific point
///
/// <ul><li>By default returns the self.offset property. You can return any other value to override that.</li></ul>
/// \param point This is the point at which the marker wants to be drawn. You can adjust the offset conditionally based on this argument.
- (CGPoint)offsetForDrawingAtPos:(CGPoint)point;

/// Draws the ChartMarker on the given position on the given context
- (void)drawWithContext:(CGContextRef _Nonnull)context point:(CGPoint)point;

/// This method enables a custom ChartMarker to update it's content everytime the MarkerView is redrawn according to the data entry it points to.
///
/// \param highlight the highlight object contains information about the highlighted value such as it's dataset-index, the selected range or stack-index (only stacked bar entries).
- (void)refreshContentWithEntry:(ChartDataEntry * _Nonnull)entry highlight:(ChartHighlight * _Nonnull)highlight;
- (UIImage * _Nonnull)imageWithView:(UIView * _Nonnull)view;
@end


SWIFT_CLASS("_TtC6Charts10ChartRange")
@interface ChartRange : NSObject
@property (nonatomic) double from;
@property (nonatomic) double to;
- (nonnull instancetype)initFrom:(double)from to:(double)to OBJC_DESIGNATED_INITIALIZER;

/// Returns true if this range contains (if the value is in between) the given value, false if not.
///
/// \param value 
- (BOOL)contains:(double)value;
- (BOOL)isLarger:(double)value;
- (BOOL)isSmaller:(double)value;
@end



SWIFT_CLASS("_TtC6Charts20ChartSelectionDetail")
@interface ChartSelectionDetail : NSObject
- (nonnull instancetype)init OBJC_DESIGNATED_INITIALIZER;
- (nonnull instancetype)initWithY:(CGFloat)y value:(double)value dataIndex:(NSInteger)dataIndex dataSetIndex:(NSInteger)dataSetIndex dataSet:(id <IChartDataSet> _Nonnull)dataSet OBJC_DESIGNATED_INITIALIZER;
- (nonnull instancetype)initWithY:(CGFloat)y value:(double)value dataSetIndex:(NSInteger)dataSetIndex dataSet:(id <IChartDataSet> _Nonnull)dataSet;
- (nonnull instancetype)initWithValue:(double)value dataSetIndex:(NSInteger)dataSetIndex dataSet:(id <IChartDataSet> _Nonnull)dataSet;
@property (nonatomic, readonly) CGFloat y;
@property (nonatomic, readonly) double value;
@property (nonatomic, readonly) NSInteger dataIndex;
@property (nonatomic, readonly) NSInteger dataSetIndex;
@property (nonatomic, readonly, strong) id <IChartDataSet> _Nullable dataSet;
- (BOOL)isEqual:(id _Nullable)object;
@end



/// Transformer class that contains all matrices and is responsible for transforming values into pixels on the screen and backwards.
SWIFT_CLASS("_TtC6Charts16ChartTransformer")
@interface ChartTransformer : NSObject
- (nonnull instancetype)initWithViewPortHandler:(ChartViewPortHandler * _Nonnull)viewPortHandler OBJC_DESIGNATED_INITIALIZER;

/// Prepares the matrix that transforms values to pixels. Calculates the scale factors from the charts size and offsets.
- (void)prepareMatrixValuePxWithChartXMin:(double)chartXMin deltaX:(CGFloat)deltaX deltaY:(CGFloat)deltaY chartYMin:(double)chartYMin;

/// Prepares the matrix that contains all offsets.
- (void)prepareMatrixOffset:(BOOL)inverted;

/// Transforms an Entry into a transformed point for bar chart
- (CGPoint)getTransformedValueBarChartWithEntry:(ChartDataEntry * _Nonnull)entry xIndex:(NSInteger)xIndex dataSetIndex:(NSInteger)dataSetIndex phaseY:(CGFloat)phaseY dataSetCount:(NSInteger)dataSetCount groupSpace:(CGFloat)groupSpace;

/// Transforms an Entry into a transformed point for horizontal bar chart
- (CGPoint)getTransformedValueHorizontalBarChartWithEntry:(ChartDataEntry * _Nonnull)entry xIndex:(NSInteger)xIndex dataSetIndex:(NSInteger)dataSetIndex phaseY:(CGFloat)phaseY dataSetCount:(NSInteger)dataSetCount groupSpace:(CGFloat)groupSpace;

/// \returns  the x and y values in the chart at the given touch point
/// (encapsulated in a PointD). This method transforms pixel coordinates to
/// coordinates / values in the chart.
- (CGPoint)getValueByTouchPoint:(CGPoint)point;
@property (nonatomic, readonly) CGAffineTransform valueToPixelMatrix;
@property (nonatomic, readonly) CGAffineTransform pixelToValueMatrix;
@end


SWIFT_CLASS("_TtC6Charts34ChartTransformerHorizontalBarChart")
@interface ChartTransformerHorizontalBarChart : ChartTransformer

/// Prepares the matrix that contains all offsets.
- (void)prepareMatrixOffset:(BOOL)inverted;
- (nonnull instancetype)initWithViewPortHandler:(ChartViewPortHandler * _Nonnull)viewPortHandler OBJC_DESIGNATED_INITIALIZER;
@end



SWIFT_PROTOCOL("_TtP6Charts17ChartViewDelegate_")
@protocol ChartViewDelegate
@optional

/// Called when a value has been selected inside the chart.
///
/// \param entry The selected Entry.
///
/// \param dataSetIndex The index in the datasets array of the data object the Entrys DataSet is in.
- (void)chartValueSelected:(ChartViewBase * _Nonnull)chartView entry:(ChartDataEntry * _Nonnull)entry dataSetIndex:(NSInteger)dataSetIndex highlight:(ChartHighlight * _Nonnull)highlight;
- (void)chartValueNothingSelected:(ChartViewBase * _Nonnull)chartView;
- (void)chartScaled:(ChartViewBase * _Nonnull)chartView scaleX:(CGFloat)scaleX scaleY:(CGFloat)scaleY;
- (void)chartTranslated:(ChartViewBase * _Nonnull)chartView dX:(CGFloat)dX dY:(CGFloat)dY;
@end



/// Class that contains information about the charts current viewport settings, including offsets, scale & translation levels, ...
SWIFT_CLASS("_TtC6Charts20ChartViewPortHandler")
@interface ChartViewPortHandler : NSObject
- (nonnull instancetype)init OBJC_DESIGNATED_INITIALIZER;

/// Constructor - don't forget calling setChartDimens(...)
- (nonnull instancetype)initWithWidth:(CGFloat)width height:(CGFloat)height OBJC_DESIGNATED_INITIALIZER;
- (void)setChartDimensWithWidth:(CGFloat)width height:(CGFloat)height;
@property (nonatomic, readonly) BOOL hasChartDimens;
- (void)restrainViewPortWithOffsetLeft:(CGFloat)offsetLeft offsetTop:(CGFloat)offsetTop offsetRight:(CGFloat)offsetRight offsetBottom:(CGFloat)offsetBottom;
@property (nonatomic, readonly) CGFloat offsetLeft;
@property (nonatomic, readonly) CGFloat offsetRight;
@property (nonatomic, readonly) CGFloat offsetTop;
@property (nonatomic, readonly) CGFloat offsetBottom;
@property (nonatomic, readonly) CGFloat contentTop;
@property (nonatomic, readonly) CGFloat contentLeft;
@property (nonatomic, readonly) CGFloat contentRight;
@property (nonatomic, readonly) CGFloat contentBottom;
@property (nonatomic, readonly) CGFloat contentWidth;
@property (nonatomic, readonly) CGFloat contentHeight;
@property (nonatomic, readonly) CGRect contentRect;
@property (nonatomic, readonly) CGPoint contentCenter;
@property (nonatomic, readonly) CGFloat chartHeight;
@property (nonatomic, readonly) CGFloat chartWidth;

/// Zooms by the specified zoom factors.
- (CGAffineTransform)zoomWithScaleX:(CGFloat)scaleX scaleY:(CGFloat)scaleY;

/// Zooms around the specified center
- (CGAffineTransform)zoomWithScaleX:(CGFloat)scaleX scaleY:(CGFloat)scaleY x:(CGFloat)x y:(CGFloat)y;

/// Zooms in by 1.4, x and y are the coordinates (in pixels) of the zoom center.
- (CGAffineTransform)zoomInX:(CGFloat)x y:(CGFloat)y;

/// Zooms out by 0.7, x and y are the coordinates (in pixels) of the zoom center.
- (CGAffineTransform)zoomOutWithX:(CGFloat)x y:(CGFloat)y;

/// Sets the scale factor to the specified values.
- (CGAffineTransform)setZoomWithScaleX:(CGFloat)scaleX scaleY:(CGFloat)scaleY;

/// Sets the scale factor to the specified values. x and y is pivot.
- (CGAffineTransform)setZoomWithScaleX:(CGFloat)scaleX scaleY:(CGFloat)scaleY x:(CGFloat)x y:(CGFloat)y;

/// Resets all zooming and dragging and makes the chart fit exactly it's bounds.
- (CGAffineTransform)fitScreen;

/// Translates to the specified point.
- (CGAffineTransform)translateWithPt:(CGPoint)pt;

/// Centers the viewport around the specified position (x-index and y-value) in the chart. Centering the viewport outside the bounds of the chart is not possible. Makes most sense in combination with the setScaleMinima(...) method.
- (void)centerViewPortWithPt:(CGPoint)pt chart:(ChartViewBase * _Nonnull)chart;

/// call this method to refresh the graph with a given matrix
- (CGAffineTransform)refreshWithNewMatrix:(CGAffineTransform)newMatrix chart:(ChartViewBase * _Nonnull)chart invalidate:(BOOL)invalidate;

/// Sets the minimum scale factor for the x-axis
- (void)setMinimumScaleX:(CGFloat)xScale;

/// Sets the maximum scale factor for the x-axis
- (void)setMaximumScaleX:(CGFloat)xScale;

/// Sets the minimum and maximum scale factors for the x-axis
- (void)setMinMaxScaleXWithMinScaleX:(CGFloat)minScaleX maxScaleX:(CGFloat)maxScaleX;

/// Sets the minimum scale factor for the y-axis
- (void)setMinimumScaleY:(CGFloat)yScale;

/// Sets the maximum scale factor for the y-axis
- (void)setMaximumScaleY:(CGFloat)yScale;
@property (nonatomic, readonly) CGAffineTransform touchMatrix;
- (BOOL)isInBoundsX:(CGFloat)x;
- (BOOL)isInBoundsY:(CGFloat)y;
- (BOOL)isInBoundsWithX:(CGFloat)x y:(CGFloat)y;
- (BOOL)isInBoundsLeft:(CGFloat)x;
- (BOOL)isInBoundsRight:(CGFloat)x;
- (BOOL)isInBoundsTop:(CGFloat)y;
- (BOOL)isInBoundsBottom:(CGFloat)y;

/// \returns  the current x-scale factor
@property (nonatomic, readonly) CGFloat scaleX;

/// \returns  the current y-scale factor
@property (nonatomic, readonly) CGFloat scaleY;

/// \returns  the minimum x-scale factor
@property (nonatomic, readonly) CGFloat minScaleX;

/// \returns  the minimum y-scale factor
@property (nonatomic, readonly) CGFloat minScaleY;

/// \returns  the minimum x-scale factor
@property (nonatomic, readonly) CGFloat maxScaleX;

/// \returns  the minimum y-scale factor
@property (nonatomic, readonly) CGFloat maxScaleY;

/// \returns  the translation (drag / pan) distance on the x-axis
@property (nonatomic, readonly) CGFloat transX;

/// \returns  the translation (drag / pan) distance on the y-axis
@property (nonatomic, readonly) CGFloat transY;

/// if the chart is fully zoomed out, return true
@property (nonatomic, readonly) BOOL isFullyZoomedOut;

/// \returns  true if the chart is fully zoomed out on it's y-axis (vertical).
@property (nonatomic, readonly) BOOL isFullyZoomedOutY;

/// \returns  true if the chart is fully zoomed out on it's x-axis (horizontal).
@property (nonatomic, readonly) BOOL isFullyZoomedOutX;

/// Set an offset in pixels that allows the user to drag the chart over it's bounds on the x-axis.
- (void)setDragOffsetX:(CGFloat)offset;

/// Set an offset in pixels that allows the user to drag the chart over it's bounds on the y-axis.
- (void)setDragOffsetY:(CGFloat)offset;

/// \returns  true if both drag offsets (x and y) are zero or smaller.
@property (nonatomic, readonly) BOOL hasNoDragOffset;

/// \returns  true if the chart is not yet fully zoomed out on the x-axis
@property (nonatomic, readonly) BOOL canZoomOutMoreX;

/// \returns  true if the chart is not yet fully zoomed in on the x-axis
@property (nonatomic, readonly) BOOL canZoomInMoreX;

/// \returns  true if the chart is not yet fully zoomed out on the y-axis
@property (nonatomic, readonly) BOOL canZoomOutMoreY;

/// \returns  true if the chart is not yet fully zoomed in on the y-axis
@property (nonatomic, readonly) BOOL canZoomInMoreY;
@end

enum XAxisLabelPosition : NSInteger;

SWIFT_CLASS("_TtC6Charts10ChartXAxis")
@interface ChartXAxis : ChartAxisBase

/// width of the x-axis labels in pixels - this is automatically calculated by the computeAxis() methods in the renderers
@property (nonatomic) CGFloat labelWidth;

/// height of the x-axis labels in pixels - this is automatically calculated by the computeAxis() methods in the renderers
@property (nonatomic) CGFloat labelHeight;

/// width of the (rotated) x-axis labels in pixels - this is automatically calculated by the computeAxis() methods in the renderers
@property (nonatomic) CGFloat labelRotatedWidth;

/// height of the (rotated) x-axis labels in pixels - this is automatically calculated by the computeAxis() methods in the renderers
@property (nonatomic) CGFloat labelRotatedHeight;

/// This is the angle for drawing the X axis labels (in degrees)
@property (nonatomic) CGFloat labelRotationAngle;

/// the space that should be left out (in characters) between the x-axis labels This only applies if the number of labels that will be skipped in between drawn axis labels is not custom set.
///
/// <em>default</em>: 4
@property (nonatomic) NSInteger spaceBetweenLabels;

/// the modulus that indicates if a value at a specified index in an array(list) for the x-axis-labels is drawn or not. Draw when (index % modulus) == 0.
@property (nonatomic) NSInteger axisLabelModulus;

/// the modulus that indicates if a value at a specified index in an array(list) for the y-axis-labels is drawn or not. Draw when (index % modulus) == 0. Used only for Horizontal BarChart
@property (nonatomic) NSInteger yAxisLabelModulus;

/// if set to true, the chart will avoid that the first and last label entry in the chart "clip" off the edge of the chart
@property (nonatomic) BOOL avoidFirstLastClippingEnabled;

/// Custom XValueFormatter for the data object that allows custom-formatting of all x-values before rendering them. Provide null to reset back to the default formatting.
@property (nonatomic, strong) id <ChartXAxisValueFormatter> _Nullable valueFormatter;

/// the position of the x-labels relative to the chart
@property (nonatomic) enum XAxisLabelPosition labelPosition;

/// if set to true, word wrapping the labels will be enabled. word wrapping is done using (value width * labelRotatedWidth)
///
/// <em>Note: currently supports all charts except pie/radar/horizontal-bar</em>
@property (nonatomic) BOOL wordWrapEnabled;

/// \returns  true if word wrapping the labels is enabled
@property (nonatomic, readonly) BOOL isWordWrapEnabled;

/// the width for wrapping the labels, as percentage out of one value width. used only when isWordWrapEnabled = true.
///
/// <em>default</em>: 1.0
@property (nonatomic) CGFloat wordWrapWidthPercent;
- (nonnull instancetype)init OBJC_DESIGNATED_INITIALIZER;
- (NSString * _Nonnull)getLongestLabel;
@property (nonatomic, readonly) BOOL isAvoidFirstLastClippingEnabled;

/// Sets the number of labels that should be skipped on the axis before the next label is drawn. This will disable the feature that automatically calculates an adequate space between the axis labels and set the number of labels to be skipped to the fixed number provided by this method. Call resetLabelsToSkip(...) to re-enable automatic calculation.
- (void)setLabelsToSkip:(NSInteger)count;

/// Calling this will disable a custom number of labels to be skipped (set by setLabelsToSkip(...)) while drawing the x-axis. Instead, the number of values to skip will again be calculated automatically.
- (void)resetLabelsToSkip;

/// \returns  true if a custom axis-modulus has been set that determines the number of labels to skip when drawing.
@property (nonatomic, readonly) BOOL isAxisModulusCustom;
@property (nonatomic, copy) NSArray<NSObject *> * _Nonnull valuesObjc;
@end

typedef SWIFT_ENUM_NAMED(NSInteger, XAxisLabelPosition, "LabelPosition") {
  XAxisLabelPositionTop = 0,
  XAxisLabelPositionBottom = 1,
  XAxisLabelPositionBothSided = 2,
  XAxisLabelPositionTopInside = 3,
  XAxisLabelPositionBottomInside = 4,
};


SWIFT_CLASS("_TtC6Charts18ChartXAxisRenderer")
@interface ChartXAxisRenderer : ChartAxisRendererBase
@property (nonatomic, strong) ChartXAxis * _Nullable xAxis;
- (nonnull instancetype)initWithViewPortHandler:(ChartViewPortHandler * _Nonnull)viewPortHandler xAxis:(ChartXAxis * _Nonnull)xAxis transformer:(ChartTransformer * _Null_unspecified)transformer OBJC_DESIGNATED_INITIALIZER;
- (void)renderAxisLabelsWithContext:(CGContextRef _Nonnull)context;
- (void)renderAxisLineWithContext:(CGContextRef _Nonnull)context;

/// draws the x-labels on the specified y-position
- (void)drawLabelsWithContext:(CGContextRef _Nonnull)context pos:(CGFloat)pos anchor:(CGPoint)anchor;
- (void)drawLabelWithContext:(CGContextRef _Nonnull)context label:(NSString * _Nonnull)label xIndex:(NSInteger)xIndex x:(CGFloat)x y:(CGFloat)y attributes:(NSDictionary<NSString *, NSObject *> * _Nonnull)attributes constrainedToSize:(CGSize)constrainedToSize anchor:(CGPoint)anchor angleRadians:(CGFloat)angleRadians;
- (void)renderGridLinesWithContext:(CGContextRef _Nonnull)context;
- (void)renderLimitLinesWithContext:(CGContextRef _Nonnull)context;
- (void)renderLimitLineLineWithContext:(CGContextRef _Nonnull)context limitLine:(ChartLimitLine * _Nonnull)limitLine position:(CGPoint)position;
- (void)renderLimitLineLabelWithContext:(CGContextRef _Nonnull)context limitLine:(ChartLimitLine * _Nonnull)limitLine position:(CGPoint)position yOffset:(CGFloat)yOffset;
@end


SWIFT_CLASS("_TtC6Charts26ChartXAxisRendererBarChart")
@interface ChartXAxisRendererBarChart : ChartXAxisRenderer
@property (nonatomic, weak) BarChartView * _Nullable chart;
- (nonnull instancetype)initWithViewPortHandler:(ChartViewPortHandler * _Nonnull)viewPortHandler xAxis:(ChartXAxis * _Nonnull)xAxis transformer:(ChartTransformer * _Null_unspecified)transformer chart:(BarChartView * _Nonnull)chart OBJC_DESIGNATED_INITIALIZER;

/// draws the x-labels on the specified y-position
- (void)drawLabelsWithContext:(CGContextRef _Nonnull)context pos:(CGFloat)pos anchor:(CGPoint)anchor;
- (void)renderGridLinesWithContext:(CGContextRef _Nonnull)context;
@end


SWIFT_CLASS("_TtC6Charts36ChartXAxisRendererHorizontalBarChart")
@interface ChartXAxisRendererHorizontalBarChart : ChartXAxisRendererBarChart
- (nonnull instancetype)initWithViewPortHandler:(ChartViewPortHandler * _Nonnull)viewPortHandler xAxis:(ChartXAxis * _Nonnull)xAxis transformer:(ChartTransformer * _Null_unspecified)transformer chart:(BarChartView * _Nonnull)chart OBJC_DESIGNATED_INITIALIZER;
- (void)renderAxisLabelsWithContext:(CGContextRef _Nonnull)context;

/// draws the x-labels on the specified y-position
- (void)drawLabelsWithContext:(CGContextRef _Nonnull)context pos:(CGFloat)pos anchor:(CGPoint)anchor;
- (void)drawLabelWithContext:(CGContextRef _Nonnull)context label:(NSString * _Nonnull)label xIndex:(NSInteger)xIndex x:(CGFloat)x y:(CGFloat)y attributes:(NSDictionary<NSString *, NSObject *> * _Nonnull)attributes anchor:(CGPoint)anchor angleRadians:(CGFloat)angleRadians;
- (void)renderGridLinesWithContext:(CGContextRef _Nonnull)context;
- (void)renderAxisLineWithContext:(CGContextRef _Nonnull)context;
- (void)renderLimitLinesWithContext:(CGContextRef _Nonnull)context;
@end

@class RadarChartView;

SWIFT_CLASS("_TtC6Charts28ChartXAxisRendererRadarChart")
@interface ChartXAxisRendererRadarChart : ChartXAxisRenderer
@property (nonatomic, weak) RadarChartView * _Nullable chart;
- (nonnull instancetype)initWithViewPortHandler:(ChartViewPortHandler * _Nonnull)viewPortHandler xAxis:(ChartXAxis * _Nonnull)xAxis chart:(RadarChartView * _Nonnull)chart OBJC_DESIGNATED_INITIALIZER;
- (void)renderAxisLabelsWithContext:(CGContextRef _Nonnull)context;
- (void)drawLabelWithContext:(CGContextRef _Nonnull)context label:(NSString * _Nonnull)label xIndex:(NSInteger)xIndex x:(CGFloat)x y:(CGFloat)y attributes:(NSDictionary<NSString *, NSObject *> * _Nonnull)attributes anchor:(CGPoint)anchor angleRadians:(CGFloat)angleRadians;
- (void)renderLimitLinesWithContext:(CGContextRef _Nonnull)context;
@end


enum YAxisLabelPosition : NSInteger;


/// Class representing the y-axis labels settings and its entries. Be aware that not all features the YLabels class provides are suitable for the RadarChart. Customizations that affect the value range of the axis need to be applied before setting data for the chart.
SWIFT_CLASS("_TtC6Charts10ChartYAxis")
@interface ChartYAxis : ChartAxisBase
@property (nonatomic, copy) NSArray<NSNumber *> * _Nonnull entries;
@property (nonatomic, readonly) NSInteger entryCount;

/// indicates if the top y-label entry is drawn or not
@property (nonatomic) BOOL drawTopYLabelEntryEnabled;

/// if true, the y-labels show only the minimum and maximum value
@property (nonatomic) BOOL showOnlyMinMaxEnabled;

/// flag that indicates if the axis is inverted or not
@property (nonatomic) BOOL inverted;

/// This property is deprecated - Use axisMinValue instead.
@property (nonatomic) BOOL startAtZeroEnabled;

/// if true, the set number of y-labels will be forced
@property (nonatomic) BOOL forceLabelsEnabled;

/// flag that indicates if the zero-line should be drawn regardless of other grid lines
@property (nonatomic) BOOL drawZeroLineEnabled;

/// Color of the zero line
@property (nonatomic, strong) UIColor * _Nullable zeroLineColor;

/// Width of the zero line
@property (nonatomic) CGFloat zeroLineWidth;

/// This is how much (in pixels) into the dash pattern are we starting from.
@property (nonatomic) CGFloat zeroLineDashPhase;

/// This is the actual dash pattern. I.e. [2, 3] will paint [--   --   ] [1, 3, 4, 2] will paint [-   ----  -   ----  ]
@property (nonatomic, copy) NSArray<NSNumber *> * _Nullable zeroLineDashLengths;

/// the formatter used to customly format the y-labels
@property (nonatomic, strong) NSNumberFormatter * _Nullable valueFormatter;

/// axis space from the largest value to the top in percent of the total axis range
@property (nonatomic) CGFloat spaceTop;

/// axis space from the smallest value to the bottom in percent of the total axis range
@property (nonatomic) CGFloat spaceBottom;

/// the position of the y-labels relative to the chart
@property (nonatomic) enum YAxisLabelPosition labelPosition;

/// the minimum width that the axis should take
///
/// <em>default</em>: 0.0
@property (nonatomic) CGFloat minWidth;

/// the maximum width that the axis can take. use Infinity for disabling the maximum.
///
/// <em>default</em>: CGFloat.infinity
@property (nonatomic) CGFloat maxWidth;

/// When true, axis labels are controlled by the granularity property. When false, axis values could possibly be repeated. This could happen if two adjacent axis values are rounded to same value. If using granularity this could be avoided by having fewer axis values visible.
@property (nonatomic) BOOL granularityEnabled;

/// The minimum interval between axis values. This can be used to avoid label duplicating when zooming in.
///
/// <em>default</em>: 1.0
@property (nonatomic) double granularity;
- (nonnull instancetype)init OBJC_DESIGNATED_INITIALIZER;
- (nonnull instancetype)initWithPosition:(enum AxisDependency)position OBJC_DESIGNATED_INITIALIZER;
@property (nonatomic, readonly) enum AxisDependency axisDependency;
- (void)setLabelCount:(NSInteger)count force:(BOOL)force;

/// the number of label entries the y-axis should have max = 25, min = 2, default = 6, be aware that this number is not fixed and can only be approximated
@property (nonatomic) NSInteger labelCount;
- (CGSize)requiredSize;
- (CGFloat)getRequiredHeightSpace;
- (NSString * _Nonnull)getLongestLabel;

/// \returns  the formatted y-label at the specified index. This will either use the auto-formatter or the custom formatter (if one is set).
- (NSString * _Nonnull)getFormattedLabel:(NSInteger)index;

/// \returns  true if this axis needs horizontal offset, false if no offset is needed.
@property (nonatomic, readonly) BOOL needsOffset;
@property (nonatomic, readonly) BOOL isInverted;

/// This is deprecated now, use axisMinValue
@property (nonatomic, readonly) BOOL isStartAtZeroEnabled;

/// \returns  true if focing the y-label count is enabled. Default: false
@property (nonatomic, readonly) BOOL isForceLabelsEnabled;
@property (nonatomic, readonly) BOOL isShowOnlyMinMaxEnabled;
@property (nonatomic, readonly) BOOL isDrawTopYLabelEntryEnabled;

/// Calculates the minimum, maximum and range values of the YAxis with the given minimum and maximum values from the chart data.
///
/// \param dataMin the y-min value according to chart data
///
/// \param dataMax the y-max value according to chart
- (void)calculateWithMin:(double)dataMin max:(double)dataMax;
@end

typedef SWIFT_ENUM_NAMED(NSInteger, YAxisLabelPosition, "LabelPosition") {
  YAxisLabelPositionOutsideChart = 0,
  YAxisLabelPositionInsideChart = 1,
};


/// Enum that specifies the axis a DataSet should be plotted against, either Left or Right.
typedef SWIFT_ENUM(NSInteger, AxisDependency) {
  AxisDependencyLeft = 0,
  AxisDependencyRight = 1,
};


SWIFT_CLASS("_TtC6Charts18ChartYAxisRenderer")
@interface ChartYAxisRenderer : ChartAxisRendererBase
@property (nonatomic, strong) ChartYAxis * _Nullable yAxis;
- (nonnull instancetype)initWithViewPortHandler:(ChartViewPortHandler * _Nonnull)viewPortHandler yAxis:(ChartYAxis * _Nonnull)yAxis transformer:(ChartTransformer * _Null_unspecified)transformer OBJC_DESIGNATED_INITIALIZER;

/// Computes the axis values.
- (void)computeAxisWithYMin:(double)yMin yMax:(double)yMax;

/// Sets up the y-axis labels. Computes the desired number of labels between the two given extremes. Unlike the papareXLabels() method, this method needs to be called upon every refresh of the view.
- (void)computeAxisValuesWithMin:(double)min max:(double)max;

/// draws the y-axis labels to the screen
- (void)renderAxisLabelsWithContext:(CGContextRef _Nonnull)context;
- (void)renderAxisLineWithContext:(CGContextRef _Nonnull)context;
- (void)renderGridLinesWithContext:(CGContextRef _Nonnull)context;

/// Draws the zero line at the specified position.
- (void)drawZeroLineWithContext:(CGContextRef _Nonnull)context x1:(CGFloat)x1 x2:(CGFloat)x2 y1:(CGFloat)y1 y2:(CGFloat)y2;
- (void)renderLimitLinesWithContext:(CGContextRef _Nonnull)context;
@end


SWIFT_CLASS("_TtC6Charts36ChartYAxisRendererHorizontalBarChart")
@interface ChartYAxisRendererHorizontalBarChart : ChartYAxisRenderer
- (nonnull instancetype)initWithViewPortHandler:(ChartViewPortHandler * _Nonnull)viewPortHandler yAxis:(ChartYAxis * _Nonnull)yAxis transformer:(ChartTransformer * _Null_unspecified)transformer OBJC_DESIGNATED_INITIALIZER;

/// Computes the axis values.
- (void)computeAxisWithYMin:(double)yMin yMax:(double)yMax;

/// draws the y-axis labels to the screen
- (void)renderAxisLabelsWithContext:(CGContextRef _Nonnull)context;
- (void)renderAxisLineWithContext:(CGContextRef _Nonnull)context;
- (void)renderGridLinesWithContext:(CGContextRef _Nonnull)context;
- (void)renderLimitLinesWithContext:(CGContextRef _Nonnull)context;
@end


SWIFT_CLASS("_TtC6Charts28ChartYAxisRendererRadarChart")
@interface ChartYAxisRendererRadarChart : ChartYAxisRenderer
- (nonnull instancetype)initWithViewPortHandler:(ChartViewPortHandler * _Nonnull)viewPortHandler yAxis:(ChartYAxis * _Nonnull)yAxis chart:(RadarChartView * _Nonnull)chart OBJC_DESIGNATED_INITIALIZER;
- (void)computeAxisWithYMin:(double)yMin yMax:(double)yMax;
- (void)computeAxisValuesWithMin:(double)yMin max:(double)yMax;
- (void)renderAxisLabelsWithContext:(CGContextRef _Nonnull)context;
- (void)renderLimitLinesWithContext:(CGContextRef _Nonnull)context;
@end

@class LineChartData;
@class ScatterChartData;

SWIFT_CLASS("_TtC6Charts17CombinedChartData")
@interface CombinedChartData : BarLineScatterCandleBubbleChartData
- (nonnull instancetype)init OBJC_DESIGNATED_INITIALIZER;
- (nonnull instancetype)initWithXVals:(NSArray<NSObject *> * _Nullable)xVals dataSets:(NSArray<id <IChartDataSet>> * _Nullable)dataSets OBJC_DESIGNATED_INITIALIZER;
@property (nonatomic, strong) LineChartData * _Null_unspecified lineData;
@property (nonatomic, strong) BarChartData * _Null_unspecified barData;
@property (nonatomic, strong) ScatterChartData * _Null_unspecified scatterData;
@property (nonatomic, strong) CandleChartData * _Null_unspecified candleData;
@property (nonatomic, strong) BubbleChartData * _Null_unspecified bubbleData;

/// \returns  all data objects in row: line-bar-scatter-candle-bubble if not null.
@property (nonatomic, readonly, copy) NSArray<ChartData *> * _Nonnull allData;
- (void)notifyDataChanged;

/// Get the Entry for a corresponding highlight object
///
/// \param highlight 
///
/// \returns  the entry that is highlighted
- (ChartDataEntry * _Nullable)getEntryForHighlight:(ChartHighlight * _Nonnull)highlight;
@end

@class CombinedChartView;

SWIFT_CLASS("_TtC6Charts21CombinedChartRenderer")
@interface CombinedChartRenderer : ChartDataRendererBase
@property (nonatomic, weak) CombinedChartView * _Nullable chart;

/// flag that enables or disables the highlighting arrow
@property (nonatomic) BOOL drawHighlightArrowEnabled;

/// if set to true, all values are drawn above their bars, instead of below their top
@property (nonatomic) BOOL drawValueAboveBarEnabled;

/// if set to true, a grey area is drawn behind each bar that indicates the maximum value
@property (nonatomic) BOOL drawBarShadowEnabled;
- (nonnull instancetype)initWithChart:(CombinedChartView * _Nonnull)chart animator:(ChartAnimator * _Nonnull)animator viewPortHandler:(ChartViewPortHandler * _Nonnull)viewPortHandler OBJC_DESIGNATED_INITIALIZER;
- (void)drawDataWithContext:(CGContextRef _Nonnull)context;
- (void)drawValuesWithContext:(CGContextRef _Nonnull)context;
- (void)drawExtrasWithContext:(CGContextRef _Nonnull)context;
- (void)drawHighlightedWithContext:(CGContextRef _Nonnull)context indices:(NSArray<ChartHighlight *> * _Nonnull)indices;
- (void)calcXBoundsWithChart:(id <BarLineScatterCandleBubbleChartDataProvider> _Nonnull)chart xAxisModulus:(NSInteger)xAxisModulus;

/// \returns  the sub-renderer object at the specified index.
- (ChartDataRendererBase * _Nullable)getSubRendererWithIndex:(NSInteger)index;

/// Returns all sub-renderers.
@property (nonatomic, copy) NSArray<ChartDataRendererBase *> * _Nonnull subRenderers;

/// \returns  true if drawing the highlighting arrow is enabled, false if not
@property (nonatomic, readonly) BOOL isDrawHighlightArrowEnabled;

/// \returns  true if drawing values above bars is enabled, false if not
@property (nonatomic, readonly) BOOL isDrawValueAboveBarEnabled;

/// \returns  true if drawing shadows (maxvalue) for each bar is enabled, false if not
@property (nonatomic, readonly) BOOL isDrawBarShadowEnabled;
@end


SWIFT_PROTOCOL("_TtP6Charts21LineChartDataProvider_")
@protocol LineChartDataProvider <BarLineScatterCandleBubbleChartDataProvider>
@property (nonatomic, readonly, strong) LineChartData * _Nullable lineData;
- (ChartYAxis * _Nonnull)getAxis:(enum AxisDependency)axis;
@end


SWIFT_PROTOCOL("_TtP6Charts24ScatterChartDataProvider_")
@protocol ScatterChartDataProvider <BarLineScatterCandleBubbleChartDataProvider>
@property (nonatomic, readonly, strong) ScatterChartData * _Nullable scatterData;
@end



/// This chart class allows the combination of lines, bars, scatter and candle data all displayed in one chart area.
SWIFT_CLASS("_TtC6Charts17CombinedChartView")
@interface CombinedChartView : BarLineChartViewBase <BarChartDataProvider, ScatterChartDataProvider, CandleChartDataProvider, BubbleChartDataProvider, LineChartDataProvider>
- (void)initialize;
@property (nonatomic, strong) ChartData * _Nullable data;
@property (nonatomic, strong) id <ChartFillFormatter> _Nonnull fillFormatter;
@property (nonatomic, readonly, strong) LineChartData * _Nullable lineData;
@property (nonatomic, readonly, strong) BarChartData * _Nullable barData;
@property (nonatomic, readonly, strong) ScatterChartData * _Nullable scatterData;
@property (nonatomic, readonly, strong) CandleChartData * _Nullable candleData;
@property (nonatomic, readonly, strong) BubbleChartData * _Nullable bubbleData;

/// flag that enables or disables the highlighting arrow
@property (nonatomic) BOOL drawHighlightArrowEnabled;

/// if set to true, all values are drawn above their bars, instead of below their top
@property (nonatomic) BOOL drawValueAboveBarEnabled;

/// if set to true, a grey area is drawn behind each bar that indicates the maximum value
@property (nonatomic) BOOL drawBarShadowEnabled;

/// \returns  true if drawing the highlighting arrow is enabled, false if not
@property (nonatomic, readonly) BOOL isDrawHighlightArrowEnabled;

/// \returns  true if drawing values above bars is enabled, false if not
@property (nonatomic, readonly) BOOL isDrawValueAboveBarEnabled;

/// \returns  true if drawing shadows (maxvalue) for each bar is enabled, false if not
@property (nonatomic, readonly) BOOL isDrawBarShadowEnabled;

/// the order in which the provided data objects should be drawn. The earlier you place them in the provided array, the further they will be in the background. e.g. if you provide [DrawOrder.Bar, DrawOrder.Line], the bars will be drawn behind the lines.
@property (nonatomic, copy) NSArray<NSNumber *> * _Nonnull drawOrder;
- (nonnull instancetype)initWithFrame:(CGRect)frame OBJC_DESIGNATED_INITIALIZER;
- (nullable instancetype)initWithCoder:(NSCoder * _Nonnull)aDecoder OBJC_DESIGNATED_INITIALIZER;
@end


/// enum that allows to specify the order in which the different data objects for the combined-chart are drawn
typedef SWIFT_ENUM_NAMED(NSInteger, CombinedChartDrawOrder, "DrawOrder") {
  CombinedChartDrawOrderBar = 0,
  CombinedChartDrawOrderBubble = 1,
  CombinedChartDrawOrderLine = 2,
  CombinedChartDrawOrderCandle = 3,
  CombinedChartDrawOrderScatter = 4,
};


SWIFT_CLASS("_TtC6Charts19CombinedHighlighter")
@interface CombinedHighlighter : ChartHighlighter
- (nonnull instancetype)initWithChart:(BarLineChartViewBase * _Nonnull)chart OBJC_DESIGNATED_INITIALIZER;
@end


SWIFT_CLASS("_TtC6Charts29HorizontalBarChartHighlighter")
@interface HorizontalBarChartHighlighter : BarChartHighlighter
- (ChartHighlight * _Nullable)getHighlightWithX:(CGFloat)x y:(CGFloat)y;
- (NSInteger)getXIndex:(CGFloat)x;

/// Returns the base y-value to the corresponding x-touch value in pixels.
///
/// \param y 
///
/// \returns  
- (double)getBase:(CGFloat)y;
- (nonnull instancetype)initWithChart:(BarLineChartViewBase * _Nonnull)chart OBJC_DESIGNATED_INITIALIZER;
@end


SWIFT_CLASS("_TtC6Charts26HorizontalBarChartRenderer")
@interface HorizontalBarChartRenderer : BarChartRenderer
- (nonnull instancetype)initWithDataProvider:(id <BarChartDataProvider> _Nullable)dataProvider animator:(ChartAnimator * _Nullable)animator viewPortHandler:(ChartViewPortHandler * _Nonnull)viewPortHandler OBJC_DESIGNATED_INITIALIZER;
- (void)drawDataSetWithContext:(CGContextRef _Nonnull)context dataSet:(id <IBarChartDataSet> _Nonnull)dataSet index:(NSInteger)index;
- (void)drawValuesWithContext:(CGContextRef _Nonnull)context;
@end



/// BarChart with horizontal bar orientation. In this implementation, x- and y-axis are switched.
SWIFT_CLASS("_TtC6Charts22HorizontalBarChartView")
@interface HorizontalBarChartView : BarChartView
- (CGRect)getBarBounds:(BarChartDataEntry * _Nonnull)e;
- (CGPoint)getPosition:(ChartDataEntry * _Nonnull)e axis:(enum AxisDependency)axis;
- (ChartHighlight * _Nullable)getHighlightByTouchPoint:(CGPoint)pt;
@property (nonatomic, readonly) NSInteger lowestVisibleXIndex;
@property (nonatomic, readonly) NSInteger highestVisibleXIndex;
- (nonnull instancetype)initWithFrame:(CGRect)frame OBJC_DESIGNATED_INITIALIZER;
- (nullable instancetype)initWithCoder:(NSCoder * _Nonnull)aDecoder OBJC_DESIGNATED_INITIALIZER;
@end







SWIFT_PROTOCOL("_TtP6Charts22ILineRadarChartDataSet_")
@protocol ILineRadarChartDataSet <ILineScatterCandleRadarChartDataSet>

/// The color that is used for filling the line surface area.
@property (nonatomic, strong) UIColor * _Nonnull fillColor;

/// Returns the object that is used for filling the area below the line. default: nil
@property (nonatomic, strong) ChartFill * _Nullable fill;

/// The alpha value that is used for filling the line surface. default: 0.33
@property (nonatomic) CGFloat fillAlpha;

/// line width of the chart (min = 0.2, max = 10)
///
/// <em>default</em>: 1
@property (nonatomic) CGFloat lineWidth;

/// Set to true if the DataSet should be drawn filled (surface), and not just as a line. Disabling this will give great performance boost. Please note that this method uses the path clipping for drawing the filled area (with images, gradients and layers).
@property (nonatomic) BOOL drawFilledEnabled;

/// Returns true if filled drawing is enabled, false if not
@property (nonatomic, readonly) BOOL isDrawFilledEnabled;
@end

enum LineChartMode : NSInteger;

SWIFT_PROTOCOL("_TtP6Charts17ILineChartDataSet_")
@protocol ILineChartDataSet <ILineRadarChartDataSet>

/// The drawing mode for this line dataset
///
/// <em>default</em>: Linear
@property (nonatomic) enum LineChartMode mode;

/// Intensity for cubic lines (min = 0.05, max = 1)
///
/// <em>default</em>: 0.2
@property (nonatomic) CGFloat cubicIntensity;
@property (nonatomic) BOOL drawCubicEnabled;
@property (nonatomic, readonly) BOOL isDrawCubicEnabled;
@property (nonatomic) BOOL drawSteppedEnabled;
@property (nonatomic, readonly) BOOL isDrawSteppedEnabled;

/// The radius of the drawn circles.
@property (nonatomic) CGFloat circleRadius;

/// The hole radius of the drawn circles.
@property (nonatomic) CGFloat circleHoleRadius;
@property (nonatomic, copy) NSArray<UIColor *> * _Nonnull circleColors;

/// \returns  the color at the given index of the DataSet's circle-color array.
/// Performs a IndexOutOfBounds check by modulus.
- (UIColor * _Nullable)getCircleColor:(NSInteger)index;

/// Sets the one and ONLY color that should be used for this DataSet. Internally, this recreates the colors array and adds the specified color.
- (void)setCircleColor:(UIColor * _Nonnull)color;

/// Resets the circle-colors array and creates a new one
- (void)resetCircleColors:(NSInteger)index;

/// If true, drawing circles is enabled
@property (nonatomic) BOOL drawCirclesEnabled;

/// \returns  true if drawing circles for this DataSet is enabled, false if not
@property (nonatomic, readonly) BOOL isDrawCirclesEnabled;

/// The color of the inner circle (the circle-hole).
@property (nonatomic, strong) UIColor * _Nullable circleHoleColor;

/// True if drawing circles for this DataSet is enabled, false if not
@property (nonatomic) BOOL drawCircleHoleEnabled;

/// \returns  true if drawing the circle-holes is enabled, false if not.
@property (nonatomic, readonly) BOOL isDrawCircleHoleEnabled;

/// This is how much (in pixels) into the dash pattern are we starting from.
@property (nonatomic, readonly) CGFloat lineDashPhase;

/// This is the actual dash pattern. I.e. [2, 3] will paint [--   --   ] [1, 3, 4, 2] will paint [-   ----  -   ----  ]
@property (nonatomic, copy) NSArray<NSNumber *> * _Nullable lineDashLengths;

/// Line cap type, default is CGLineCap.Butt
@property (nonatomic) CGLineCap lineCapType;

/// Sets a custom FillFormatter to the chart that handles the position of the filled-line for each DataSet. Set this to null to use the default logic.
@property (nonatomic, strong) id <ChartFillFormatter> _Nullable fillFormatter;
@end



enum PieChartValuePosition : NSInteger;

SWIFT_PROTOCOL("_TtP6Charts16IPieChartDataSet_")
@protocol IPieChartDataSet <IChartDataSet>

/// the space in pixels between the pie-slices default: 0 maximum: 20
@property (nonatomic) CGFloat sliceSpace;

/// indicates the selection distance of a pie slice
@property (nonatomic) CGFloat selectionShift;
@property (nonatomic) enum PieChartValuePosition xValuePosition;
@property (nonatomic) enum PieChartValuePosition yValuePosition;

/// When valuePosition is OutsideSlice, indicates line color
@property (nonatomic, strong) UIColor * _Nullable valueLineColor;

/// When valuePosition is OutsideSlice, indicates line width
@property (nonatomic) CGFloat valueLineWidth;

/// When valuePosition is OutsideSlice, indicates offset as percentage out of the slice size
@property (nonatomic) CGFloat valueLinePart1OffsetPercentage;

/// When valuePosition is OutsideSlice, indicates length of first half of the line
@property (nonatomic) CGFloat valueLinePart1Length;

/// When valuePosition is OutsideSlice, indicates length of second half of the line
@property (nonatomic) CGFloat valueLinePart2Length;

/// When valuePosition is OutsideSlice, this allows variable line length
@property (nonatomic) BOOL valueLineVariableLength;
@end


SWIFT_PROTOCOL("_TtP6Charts18IRadarChartDataSet_")
@protocol IRadarChartDataSet <ILineRadarChartDataSet>

/// flag indicating whether highlight circle should be drawn or not
@property (nonatomic) BOOL drawHighlightCircleEnabled;
@property (nonatomic, readonly) BOOL isDrawHighlightCircleEnabled;
@property (nonatomic, strong) UIColor * _Nullable highlightCircleFillColor;

/// The stroke color for highlight circle. If nil, the color of the dataset is taken.
@property (nonatomic, strong) UIColor * _Nullable highlightCircleStrokeColor;
@property (nonatomic) CGFloat highlightCircleStrokeAlpha;
@property (nonatomic) CGFloat highlightCircleInnerRadius;
@property (nonatomic) CGFloat highlightCircleOuterRadius;
@property (nonatomic) CGFloat highlightCircleStrokeWidth;
@end

enum ScatterShape : NSInteger;

SWIFT_PROTOCOL("_TtP6Charts20IScatterChartDataSet_")
@protocol IScatterChartDataSet <ILineScatterCandleRadarChartDataSet>
@property (nonatomic) CGFloat scatterShapeSize;
@property (nonatomic) enum ScatterShape scatterShape;
@property (nonatomic) CGFloat scatterShapeHoleRadius;
@property (nonatomic, strong) UIColor * _Nullable scatterShapeHoleColor;
@property (nonatomic) CGPathRef _Nullable customScatterShape;
@end



/// Data object that encapsulates all data associated with a LineChart.
SWIFT_CLASS("_TtC6Charts13LineChartData")
@interface LineChartData : ChartData
- (nonnull instancetype)init OBJC_DESIGNATED_INITIALIZER;
- (nonnull instancetype)initWithXVals:(NSArray<NSObject *> * _Nullable)xVals dataSets:(NSArray<id <IChartDataSet>> * _Nullable)dataSets OBJC_DESIGNATED_INITIALIZER;
@end



SWIFT_CLASS("_TtC6Charts21LineRadarChartDataSet")
@interface LineRadarChartDataSet : LineScatterCandleRadarChartDataSet <ILineRadarChartDataSet>

/// The color that is used for filling the line surface area.
@property (nonatomic, strong) UIColor * _Nonnull fillColor;

/// The object that is used for filling the area below the line. default: nil
@property (nonatomic, strong) ChartFill * _Nullable fill;

/// The alpha value that is used for filling the line surface, default: 0.33
@property (nonatomic) CGFloat fillAlpha;

/// line width of the chart (min = 0.2, max = 10)
///
/// <em>default</em>: 1
@property (nonatomic) CGFloat lineWidth;

/// Set to true if the DataSet should be drawn filled (surface), and not just as a line. Disabling this will give great performance boost. Please note that this method uses the path clipping for drawing the filled area (with images, gradients and layers).
@property (nonatomic) BOOL drawFilledEnabled;

/// Returns true if filled drawing is enabled, false if not
@property (nonatomic, readonly) BOOL isDrawFilledEnabled;
- (id _Nonnull)copyWithZone:(struct _NSZone * _Null_unspecified)zone;
- (nonnull instancetype)init OBJC_DESIGNATED_INITIALIZER;
- (nonnull instancetype)initWithLabel:(NSString * _Nullable)label OBJC_DESIGNATED_INITIALIZER;
- (nonnull instancetype)initWithYVals:(NSArray<ChartDataEntry *> * _Nullable)yVals label:(NSString * _Nullable)label OBJC_DESIGNATED_INITIALIZER;
@end


SWIFT_CLASS("_TtC6Charts16LineChartDataSet")
@interface LineChartDataSet : LineRadarChartDataSet <ILineChartDataSet>
- (nonnull instancetype)init OBJC_DESIGNATED_INITIALIZER;
- (nonnull instancetype)initWithYVals:(NSArray<ChartDataEntry *> * _Nullable)yVals label:(NSString * _Nullable)label OBJC_DESIGNATED_INITIALIZER;

/// The drawing mode for this line dataset
///
/// <em>default</em>: Linear
@property (nonatomic) enum LineChartMode mode;

/// Intensity for cubic lines (min = 0.05, max = 1)
///
/// <em>default</em>: 0.2
@property (nonatomic) CGFloat cubicIntensity;
@property (nonatomic) BOOL drawCubicEnabled;
@property (nonatomic, readonly) BOOL isDrawCubicEnabled;
@property (nonatomic) BOOL drawSteppedEnabled;
@property (nonatomic, readonly) BOOL isDrawSteppedEnabled;

/// The radius of the drawn circles.
@property (nonatomic) CGFloat circleRadius;

/// The hole radius of the drawn circles
@property (nonatomic) CGFloat circleHoleRadius;
@property (nonatomic, copy) NSArray<UIColor *> * _Nonnull circleColors;

/// \returns  the color at the given index of the DataSet's circle-color array.
/// Performs a IndexOutOfBounds check by modulus.
- (UIColor * _Nullable)getCircleColor:(NSInteger)index;

/// Sets the one and ONLY color that should be used for this DataSet. Internally, this recreates the colors array and adds the specified color.
- (void)setCircleColor:(UIColor * _Nonnull)color;

/// Resets the circle-colors array and creates a new one
- (void)resetCircleColors:(NSInteger)index;

/// If true, drawing circles is enabled
@property (nonatomic) BOOL drawCirclesEnabled;

/// \returns  true if drawing circles for this DataSet is enabled, false if not
@property (nonatomic, readonly) BOOL isDrawCirclesEnabled;

/// The color of the inner circle (the circle-hole).
@property (nonatomic, strong) UIColor * _Nullable circleHoleColor;

/// True if drawing circles for this DataSet is enabled, false if not
@property (nonatomic) BOOL drawCircleHoleEnabled;

/// \returns  true if drawing the circle-holes is enabled, false if not.
@property (nonatomic, readonly) BOOL isDrawCircleHoleEnabled;

/// This is how much (in pixels) into the dash pattern are we starting from.
@property (nonatomic) CGFloat lineDashPhase;

/// This is the actual dash pattern. I.e. [2, 3] will paint [--   --   ] [1, 3, 4, 2] will paint [-   ----  -   ----  ]
@property (nonatomic, copy) NSArray<NSNumber *> * _Nullable lineDashLengths;

/// Line cap type, default is CGLineCap.Butt
@property (nonatomic) CGLineCap lineCapType;

/// Sets a custom FillFormatter to the chart that handles the position of the filled-line for each DataSet. Set this to null to use the default logic.
@property (nonatomic, strong) id <ChartFillFormatter> _Nullable fillFormatter;
- (id _Nonnull)copyWithZone:(struct _NSZone * _Null_unspecified)zone;
@end

typedef SWIFT_ENUM_NAMED(NSInteger, LineChartMode, "Mode") {
  LineChartModeLinear = 0,
  LineChartModeStepped = 1,
  LineChartModeCubicBezier = 2,
  LineChartModeHorizontalBezier = 3,
};


SWIFT_CLASS("_TtC6Charts22LineRadarChartRenderer")
@interface LineRadarChartRenderer : LineScatterCandleRadarChartRenderer
- (nonnull instancetype)initWithAnimator:(ChartAnimator * _Nullable)animator viewPortHandler:(ChartViewPortHandler * _Nonnull)viewPortHandler OBJC_DESIGNATED_INITIALIZER;

/// Draws the provided path in filled mode with the provided drawable.
- (void)drawFilledPathWithContext:(CGContextRef _Nonnull)context path:(CGPathRef _Nonnull)path fill:(ChartFill * _Nonnull)fill fillAlpha:(CGFloat)fillAlpha;

/// Draws the provided path in filled mode with the provided color and alpha.
- (void)drawFilledPathWithContext:(CGContextRef _Nonnull)context path:(CGPathRef _Nonnull)path fillColor:(UIColor * _Nonnull)fillColor fillAlpha:(CGFloat)fillAlpha;
@end


SWIFT_CLASS("_TtC6Charts17LineChartRenderer")
@interface LineChartRenderer : LineRadarChartRenderer
@property (nonatomic, weak) id <LineChartDataProvider> _Nullable dataProvider;
- (nonnull instancetype)initWithDataProvider:(id <LineChartDataProvider> _Nullable)dataProvider animator:(ChartAnimator * _Nullable)animator viewPortHandler:(ChartViewPortHandler * _Nonnull)viewPortHandler OBJC_DESIGNATED_INITIALIZER;
- (void)drawDataWithContext:(CGContextRef _Nonnull)context;
- (void)drawDataSetWithContext:(CGContextRef _Nonnull)context dataSet:(id <ILineChartDataSet> _Nonnull)dataSet;
- (void)drawCubicBezierWithContext:(CGContextRef _Nonnull)context dataSet:(id <ILineChartDataSet> _Nonnull)dataSet;
- (void)drawHorizontalBezierWithContext:(CGContextRef _Nonnull)context dataSet:(id <ILineChartDataSet> _Nonnull)dataSet;
- (void)drawCubicFillWithContext:(CGContextRef _Nonnull)context dataSet:(id <ILineChartDataSet> _Nonnull)dataSet spline:(CGMutablePathRef _Nonnull)spline matrix:(CGAffineTransform)matrix from:(NSInteger)from to:(NSInteger)to;
- (void)drawLinearWithContext:(CGContextRef _Nonnull)context dataSet:(id <ILineChartDataSet> _Nonnull)dataSet;
- (void)drawLinearFillWithContext:(CGContextRef _Nonnull)context dataSet:(id <ILineChartDataSet> _Nonnull)dataSet minx:(NSInteger)minx maxx:(NSInteger)maxx trans:(ChartTransformer * _Nonnull)trans;
- (void)drawValuesWithContext:(CGContextRef _Nonnull)context;
- (void)drawExtrasWithContext:(CGContextRef _Nonnull)context;
- (void)drawHighlightedWithContext:(CGContextRef _Nonnull)context indices:(NSArray<ChartHighlight *> * _Nonnull)indices;
@end



/// Chart that draws lines, surfaces, circles, ...
SWIFT_CLASS("_TtC6Charts13LineChartView")
@interface LineChartView : BarLineChartViewBase <LineChartDataProvider>
@property (nonatomic, readonly, strong) LineChartData * _Nullable lineData;
- (nonnull instancetype)initWithFrame:(CGRect)frame OBJC_DESIGNATED_INITIALIZER;
- (nullable instancetype)initWithCoder:(NSCoder * _Nonnull)aDecoder OBJC_DESIGNATED_INITIALIZER;
@end







SWIFT_CLASS("_TtC6Charts12PieChartData")
@interface PieChartData : ChartData
- (nonnull instancetype)init OBJC_DESIGNATED_INITIALIZER;
- (nonnull instancetype)initWithXVals:(NSArray<NSObject *> * _Nullable)xVals dataSets:(NSArray<id <IChartDataSet>> * _Nullable)dataSets OBJC_DESIGNATED_INITIALIZER;
- (id <IChartDataSet> _Nullable)getDataSetByIndex:(NSInteger)index;
- (id <IChartDataSet> _Nullable)getDataSetByLabel:(NSString * _Nonnull)label ignorecase:(BOOL)ignorecase;
- (void)addDataSet:(id <IChartDataSet> _Null_unspecified)d;

/// Removes the DataSet at the given index in the DataSet array from the data object. Also recalculates all minimum and maximum values.
///
/// \returns  true if a DataSet was removed, false if no DataSet could be removed.
- (BOOL)removeDataSetByIndex:(NSInteger)index;

/// \returns  the total y-value sum across all DataSet objects the this object represents.
@property (nonatomic, readonly) double yValueSum;
@end


SWIFT_CLASS("_TtC6Charts15PieChartDataSet")
@interface PieChartDataSet : ChartDataSet <IPieChartDataSet>
- (nonnull instancetype)init OBJC_DESIGNATED_INITIALIZER;
- (nonnull instancetype)initWithYVals:(NSArray<ChartDataEntry *> * _Nullable)yVals label:(NSString * _Nullable)label OBJC_DESIGNATED_INITIALIZER;

/// the space in pixels between the pie-slices default: 0 maximum: 20
@property (nonatomic) CGFloat sliceSpace;

/// indicates the selection distance of a pie slice
@property (nonatomic) CGFloat selectionShift;
@property (nonatomic) enum PieChartValuePosition xValuePosition;
@property (nonatomic) enum PieChartValuePosition yValuePosition;

/// When valuePosition is OutsideSlice, indicates line color
@property (nonatomic, strong) UIColor * _Nullable valueLineColor;

/// When valuePosition is OutsideSlice, indicates line width
@property (nonatomic) CGFloat valueLineWidth;

/// When valuePosition is OutsideSlice, indicates offset as percentage out of the slice size
@property (nonatomic) CGFloat valueLinePart1OffsetPercentage;

/// When valuePosition is OutsideSlice, indicates length of first half of the line
@property (nonatomic) CGFloat valueLinePart1Length;

/// When valuePosition is OutsideSlice, indicates length of second half of the line
@property (nonatomic) CGFloat valueLinePart2Length;

/// When valuePosition is OutsideSlice, this allows variable line length
@property (nonatomic) BOOL valueLineVariableLength;
- (id _Nonnull)copyWithZone:(struct _NSZone * _Null_unspecified)zone;
@end

typedef SWIFT_ENUM_NAMED(NSInteger, PieChartValuePosition, "ValuePosition") {
  PieChartValuePositionInsideSlice = 0,
  PieChartValuePositionOutsideSlice = 1,
};

@class PieChartView;

SWIFT_CLASS("_TtC6Charts16PieChartRenderer")
@interface PieChartRenderer : ChartDataRendererBase
@property (nonatomic, weak) PieChartView * _Nullable chart;
- (nonnull instancetype)initWithChart:(PieChartView * _Nonnull)chart animator:(ChartAnimator * _Nullable)animator viewPortHandler:(ChartViewPortHandler * _Nonnull)viewPortHandler OBJC_DESIGNATED_INITIALIZER;
- (void)drawDataWithContext:(CGContextRef _Nonnull)context;
- (CGFloat)calculateMinimumRadiusForSpacedSliceWithCenter:(CGPoint)center radius:(CGFloat)radius angle:(CGFloat)angle arcStartPointX:(CGFloat)arcStartPointX arcStartPointY:(CGFloat)arcStartPointY startAngle:(CGFloat)startAngle sweepAngle:(CGFloat)sweepAngle;
- (void)drawDataSetWithContext:(CGContextRef _Nonnull)context dataSet:(id <IPieChartDataSet> _Nonnull)dataSet;
- (void)drawValuesWithContext:(CGContextRef _Nonnull)context;
- (void)drawExtrasWithContext:(CGContextRef _Nonnull)context;
- (void)drawHighlightedWithContext:(CGContextRef _Nonnull)context indices:(NSArray<ChartHighlight *> * _Nonnull)indices;
@end



/// Base class of PieChartView and RadarChartView.
SWIFT_CLASS("_TtC6Charts21PieRadarChartViewBase")
@interface PieRadarChartViewBase : ChartViewBase

/// flag that indicates if rotation is enabled or not
@property (nonatomic) BOOL rotationEnabled;

/// Sets the minimum offset (padding) around the chart, defaults to 0.0
@property (nonatomic) CGFloat minOffset;
- (nonnull instancetype)initWithFrame:(CGRect)frame OBJC_DESIGNATED_INITIALIZER;
- (nullable instancetype)initWithCoder:(NSCoder * _Nonnull)aDecoder OBJC_DESIGNATED_INITIALIZER;
- (void)notifyDataSetChanged;

/// \returns  the angle relative to the chart center for the given point on the chart in degrees.
/// The angle is always between 0 and 360°, 0° is NORTH, 90° is EAST, ...
- (CGFloat)angleForPointWithX:(CGFloat)x y:(CGFloat)y;

/// \returns  the distance of a certain point on the chart to the center of the chart.
- (CGFloat)distanceToCenterWithX:(CGFloat)x y:(CGFloat)y;

/// \returns  the xIndex for the given angle around the center of the chart.
/// -1 if not found / outofbounds.
- (NSInteger)indexForAngle:(CGFloat)angle;

/// current rotation angle of the pie chart
///
/// <em>default</em>: 270 --> top (NORTH)
///
/// \returns  will always return a normalized value, which will be between 0.0 < 360.0
@property (nonatomic) CGFloat rotationAngle;

/// gets the raw version of the current rotation angle of the pie chart the returned value could be any value, negative or positive, outside of the 360 degrees. this is used when working with rotation direction, mainly by gestures and animations.
@property (nonatomic, readonly) CGFloat rawRotationAngle;

/// \returns  the diameter of the pie- or radar-chart
@property (nonatomic, readonly) CGFloat diameter;

/// \returns  the radius of the chart in pixels.
@property (nonatomic, readonly) CGFloat radius;
@property (nonatomic, readonly) double chartYMax;
@property (nonatomic, readonly) double chartYMin;

/// The SelectionDetail objects give information about the value at the selected index and the DataSet it belongs to.
///
/// \returns  an array of SelectionDetail objects for the given x-index.
- (NSArray<ChartSelectionDetail *> * _Nonnull)getSelectionDetailsAtIndex:(NSInteger)xIndex;
@property (nonatomic, readonly) BOOL isRotationEnabled;

/// flag that indicates if rotation is done with two fingers or one. when the chart is inside a scrollview, you need a two-finger rotation because a one-finger rotation eats up all touch events.
///
/// On iOS this will disable one-finger rotation.
/// On OSX this will keep two-finger multitouch rotation, and one-pointer mouse rotation.
///
/// <em>default</em>: false
@property (nonatomic) BOOL rotationWithTwoFingers;

/// flag that indicates if rotation is done with two fingers or one. when the chart is inside a scrollview, you need a two-finger rotation because a one-finger rotation eats up all touch events.
///
/// On iOS this will disable one-finger rotation.
/// On OSX this will keep two-finger multitouch rotation, and one-pointer mouse rotation.
///
/// <em>default</em>: false
@property (nonatomic, readonly) BOOL isRotationWithTwoFingers;

/// Applys a spin animation to the Chart.
- (void)spinWithDuration:(NSTimeInterval)duration fromAngle:(CGFloat)fromAngle toAngle:(CGFloat)toAngle easing:(CGFloat (^ _Nullable)(NSTimeInterval elapsed, NSTimeInterval duration))easing;
- (void)spinWithDuration:(NSTimeInterval)duration fromAngle:(CGFloat)fromAngle toAngle:(CGFloat)toAngle easingOption:(enum ChartEasingOption)easingOption;
- (void)spinWithDuration:(NSTimeInterval)duration fromAngle:(CGFloat)fromAngle toAngle:(CGFloat)toAngle;
- (void)stopSpinAnimation;
- (void)nsuiTouchesBegan:(NSSet<UITouch *> * _Nonnull)touches withEvent:(UIEvent * _Nullable)event;
- (void)nsuiTouchesMoved:(NSSet<UITouch *> * _Nonnull)touches withEvent:(UIEvent * _Nullable)event;
- (void)nsuiTouchesEnded:(NSSet<UITouch *> * _Nonnull)touches withEvent:(UIEvent * _Nullable)event;
- (void)nsuiTouchesCancelled:(NSSet<UITouch *> * _Nullable)touches withEvent:(UIEvent * _Nullable)event;
- (void)stopDeceleration;
@end

@class NSAttributedString;


/// View that represents a pie chart. Draws cake like slices.
SWIFT_CLASS("_TtC6Charts12PieChartView")
@interface PieChartView : PieRadarChartViewBase
- (nonnull instancetype)initWithFrame:(CGRect)frame OBJC_DESIGNATED_INITIALIZER;
- (nullable instancetype)initWithCoder:(NSCoder * _Nonnull)aDecoder OBJC_DESIGNATED_INITIALIZER;
- (void)drawRect:(CGRect)rect;
- (CGPoint)getMarkerPositionWithEntry:(ChartDataEntry * _Nonnull)e highlight:(ChartHighlight * _Nonnull)highlight;

/// checks if the given index in the given DataSet is set for highlighting or not
- (BOOL)needsHighlightWithXIndex:(NSInteger)xIndex dataSetIndex:(NSInteger)dataSetIndex;

/// This will throw an exception, PieChart has no XAxis object.
@property (nonatomic, readonly, strong) ChartXAxis * _Nonnull xAxis;
- (NSInteger)indexForAngle:(CGFloat)angle;

/// \returns  the index of the DataSet this x-index belongs to.
- (NSInteger)dataSetIndexForIndex:(NSInteger)xIndex;

/// \returns  an integer array of all the different angles the chart slices
/// have the angles in the returned array determine how much space (of 360°)
/// each slice takes
@property (nonatomic, readonly, copy) NSArray<NSNumber *> * _Nonnull drawAngles;

/// \returns  the absolute angles of the different chart slices (where the
/// slices end)
@property (nonatomic, readonly, copy) NSArray<NSNumber *> * _Nonnull absoluteAngles;

/// The color for the hole that is drawn in the center of the PieChart (if enabled).
///
/// <em>Note: Use holeTransparent with holeColor = nil to make the hole transparent.</em>
@property (nonatomic, strong) UIColor * _Nullable holeColor;

/// if true, the hole will see-through to the inner tips of the slices
///
/// <em>default</em>: <code>false
/// </code>
@property (nonatomic) BOOL drawSlicesUnderHoleEnabled;

/// \returns  <code>true
/// </code> if the inner tips of the slices are visible behind the hole, <code>false
/// </code> if not.
@property (nonatomic, readonly) BOOL isDrawSlicesUnderHoleEnabled;

/// true if the hole in the center of the pie-chart is set to be visible, false if not
@property (nonatomic) BOOL drawHoleEnabled;

/// \returns  true if the hole in the center of the pie-chart is set to be visible, false if not
@property (nonatomic, readonly) BOOL isDrawHoleEnabled;

/// the text that is displayed in the center of the pie-chart
@property (nonatomic, copy) NSString * _Nullable centerText;

/// the text that is displayed in the center of the pie-chart
@property (nonatomic, strong) NSAttributedString * _Nullable centerAttributedText;

/// true if drawing the center text is enabled
@property (nonatomic) BOOL drawCenterTextEnabled;

/// \returns  true if drawing the center text is enabled
@property (nonatomic, readonly) BOOL isDrawCenterTextEnabled;
@property (nonatomic, readonly) CGFloat radius;

/// \returns  the circlebox, the boundingbox of the pie-chart slices
@property (nonatomic, readonly) CGRect circleBox;

/// \returns  the center of the circlebox
@property (nonatomic, readonly) CGPoint centerCircleBox;

/// the radius of the hole in the center of the piechart in percent of the maximum radius (max = the radius of the whole chart)
///
/// <em>default</em>: 0.5 (50%) (half the pie)
@property (nonatomic) CGFloat holeRadiusPercent;

/// The color that the transparent-circle should have.
///
/// <em>default</em>: <code>nil
/// </code>
@property (nonatomic, strong) UIColor * _Nullable transparentCircleColor;

/// the radius of the transparent circle that is drawn next to the hole in the piechart in percent of the maximum radius (max = the radius of the whole chart)
///
/// <em>default</em>: 0.55 (55%) -> means 5% larger than the center-hole by default
@property (nonatomic) CGFloat transparentCircleRadiusPercent;

/// set this to true to draw the x-value text into the pie slices
@property (nonatomic) BOOL drawSliceTextEnabled;

/// \returns  true if drawing x-values is enabled, false if not
@property (nonatomic, readonly) BOOL isDrawSliceTextEnabled;

/// If this is enabled, values inside the PieChart are drawn in percent and not with their original value. Values provided for the ValueFormatter to format are then provided in percent.
@property (nonatomic) BOOL usePercentValuesEnabled;

/// \returns  true if drawing x-values is enabled, false if not
@property (nonatomic, readonly) BOOL isUsePercentValuesEnabled;

/// the rectangular radius of the bounding box for the center text, as a percentage of the pie hole
@property (nonatomic) CGFloat centerTextRadiusPercent;

/// The max angle that is used for calculating the pie-circle. 360 means it's a full pie-chart, 180 results in a half-pie-chart. default: 360.0
@property (nonatomic) CGFloat maxAngle;
@end



SWIFT_CLASS("_TtC6Charts14RadarChartData")
@interface RadarChartData : ChartData
@property (nonatomic, strong) UIColor * _Nonnull highlightColor;
@property (nonatomic) CGFloat highlightLineWidth;
@property (nonatomic) CGFloat highlightLineDashPhase;
@property (nonatomic, copy) NSArray<NSNumber *> * _Nullable highlightLineDashLengths;
- (nonnull instancetype)init OBJC_DESIGNATED_INITIALIZER;
- (nonnull instancetype)initWithXVals:(NSArray<NSObject *> * _Nullable)xVals dataSets:(NSArray<id <IChartDataSet>> * _Nullable)dataSets OBJC_DESIGNATED_INITIALIZER;
@end


SWIFT_CLASS("_TtC6Charts17RadarChartDataSet")
@interface RadarChartDataSet : LineRadarChartDataSet <IRadarChartDataSet>
- (nonnull instancetype)init OBJC_DESIGNATED_INITIALIZER;
- (nonnull instancetype)initWithYVals:(NSArray<ChartDataEntry *> * _Nullable)yVals label:(NSString * _Nullable)label OBJC_DESIGNATED_INITIALIZER;

/// flag indicating whether highlight circle should be drawn or not default: false
@property (nonatomic) BOOL drawHighlightCircleEnabled;

/// \returns  true if highlight circle should be drawn, false if not
@property (nonatomic, readonly) BOOL isDrawHighlightCircleEnabled;
@property (nonatomic, strong) UIColor * _Nullable highlightCircleFillColor;

/// The stroke color for highlight circle. If nil, the color of the dataset is taken.
@property (nonatomic, strong) UIColor * _Nullable highlightCircleStrokeColor;
@property (nonatomic) CGFloat highlightCircleStrokeAlpha;
@property (nonatomic) CGFloat highlightCircleInnerRadius;
@property (nonatomic) CGFloat highlightCircleOuterRadius;
@property (nonatomic) CGFloat highlightCircleStrokeWidth;
@end


SWIFT_CLASS("_TtC6Charts18RadarChartRenderer")
@interface RadarChartRenderer : LineRadarChartRenderer
@property (nonatomic, weak) RadarChartView * _Nullable chart;
- (nonnull instancetype)initWithChart:(RadarChartView * _Nonnull)chart animator:(ChartAnimator * _Nullable)animator viewPortHandler:(ChartViewPortHandler * _Nonnull)viewPortHandler OBJC_DESIGNATED_INITIALIZER;
- (void)drawDataWithContext:(CGContextRef _Nonnull)context;
- (void)drawValuesWithContext:(CGContextRef _Nonnull)context;
- (void)drawExtrasWithContext:(CGContextRef _Nonnull)context;
- (void)drawWebWithContext:(CGContextRef _Nonnull)context;
- (void)drawHighlightedWithContext:(CGContextRef _Nonnull)context indices:(NSArray<ChartHighlight *> * _Nonnull)indices;
@end



/// Implementation of the RadarChart, a "spidernet"-like chart. It works best when displaying 5-10 entries per DataSet.
SWIFT_CLASS("_TtC6Charts14RadarChartView")
@interface RadarChartView : PieRadarChartViewBase

/// width of the web lines that come from the center.
@property (nonatomic) CGFloat webLineWidth;

/// width of the web lines that are in between the lines coming from the center
@property (nonatomic) CGFloat innerWebLineWidth;

/// color for the web lines that come from the center
@property (nonatomic, strong) UIColor * _Nonnull webColor;

/// color for the web lines in between the lines that come from the center.
@property (nonatomic, strong) UIColor * _Nonnull innerWebColor;

/// transparency the grid is drawn with (0.0 - 1.0)
@property (nonatomic) CGFloat webAlpha;

/// flag indicating if the web lines should be drawn or not
@property (nonatomic) BOOL drawWeb;
- (nonnull instancetype)initWithFrame:(CGRect)frame OBJC_DESIGNATED_INITIALIZER;
- (nullable instancetype)initWithCoder:(NSCoder * _Nonnull)aDecoder OBJC_DESIGNATED_INITIALIZER;
- (CGPoint)getMarkerPositionWithEntry:(ChartDataEntry * _Nonnull)entry highlight:(ChartHighlight * _Nonnull)highlight;
- (void)notifyDataSetChanged;
- (void)drawRect:(CGRect)rect;

/// \returns  the factor that is needed to transform values into pixels.
@property (nonatomic, readonly) CGFloat factor;

/// \returns  the angle that each slice in the radar chart occupies.
@property (nonatomic, readonly) CGFloat sliceAngle;
- (NSInteger)indexForAngle:(CGFloat)angle;

/// \returns  the object that represents all y-labels of the RadarChart.
@property (nonatomic, readonly, strong) ChartYAxis * _Nonnull yAxis;

/// Sets the number of web-lines that should be skipped on chart web before the next one is drawn. This targets the lines that come from the center of the RadarChart. if count = 1 -> 1 line is skipped in between
@property (nonatomic) NSInteger skipWebLineCount;
@property (nonatomic, readonly) CGFloat radius;

/// \returns  the maximum value this chart can display on it's y-axis.
@property (nonatomic, readonly) double chartYMax;

/// \returns  the minimum value this chart can display on it's y-axis.
@property (nonatomic, readonly) double chartYMin;

/// \returns  the range of y-values this chart can display.
@property (nonatomic, readonly) double yRange;
@end


SWIFT_CLASS("_TtC6Charts16ScatterChartData")
@interface ScatterChartData : BarLineScatterCandleBubbleChartData
- (nonnull instancetype)init OBJC_DESIGNATED_INITIALIZER;
- (nonnull instancetype)initWithXVals:(NSArray<NSObject *> * _Nullable)xVals dataSets:(NSArray<id <IChartDataSet>> * _Nullable)dataSets OBJC_DESIGNATED_INITIALIZER;

/// \returns  the maximum shape-size across all DataSets.
- (CGFloat)getGreatestShapeSize;
@end



SWIFT_CLASS("_TtC6Charts19ScatterChartDataSet")
@interface ScatterChartDataSet : LineScatterCandleRadarChartDataSet <IScatterChartDataSet>
@property (nonatomic) CGFloat scatterShapeSize;
@property (nonatomic) enum ScatterShape scatterShape;
@property (nonatomic) CGFloat scatterShapeHoleRadius;
@property (nonatomic, strong) UIColor * _Nullable scatterShapeHoleColor;
@property (nonatomic) CGPathRef _Nullable customScatterShape;
- (id _Nonnull)copyWithZone:(struct _NSZone * _Null_unspecified)zone;
- (nonnull instancetype)init OBJC_DESIGNATED_INITIALIZER;
- (nonnull instancetype)initWithLabel:(NSString * _Nullable)label OBJC_DESIGNATED_INITIALIZER;
- (nonnull instancetype)initWithYVals:(NSArray<ChartDataEntry *> * _Nullable)yVals label:(NSString * _Nullable)label OBJC_DESIGNATED_INITIALIZER;
@end

typedef SWIFT_ENUM_NAMED(NSInteger, ScatterShape, "Shape") {
  ScatterShapeSquare = 0,
  ScatterShapeCircle = 1,
  ScatterShapeTriangle = 2,
  ScatterShapeCross = 3,
  ScatterShapeX = 4,
  ScatterShapeCustom = 5,
};


SWIFT_CLASS("_TtC6Charts20ScatterChartRenderer")
@interface ScatterChartRenderer : LineScatterCandleRadarChartRenderer
@property (nonatomic, weak) id <ScatterChartDataProvider> _Nullable dataProvider;
- (nonnull instancetype)initWithDataProvider:(id <ScatterChartDataProvider> _Nullable)dataProvider animator:(ChartAnimator * _Nullable)animator viewPortHandler:(ChartViewPortHandler * _Nonnull)viewPortHandler OBJC_DESIGNATED_INITIALIZER;
- (void)drawDataWithContext:(CGContextRef _Nonnull)context;
- (void)drawDataSetWithContext:(CGContextRef _Nonnull)context dataSet:(id <IScatterChartDataSet> _Nonnull)dataSet;
- (void)drawValuesWithContext:(CGContextRef _Nonnull)context;
- (void)drawExtrasWithContext:(CGContextRef _Nonnull)context;
- (void)drawHighlightedWithContext:(CGContextRef _Nonnull)context indices:(NSArray<ChartHighlight *> * _Nonnull)indices;
@end



/// The ScatterChart. Draws dots, triangles, squares and custom shapes into the chartview.
SWIFT_CLASS("_TtC6Charts16ScatterChartView")
@interface ScatterChartView : BarLineChartViewBase <ScatterChartDataProvider>
- (void)initialize;
- (void)calcMinMax;
@property (nonatomic, readonly, strong) ScatterChartData * _Nullable scatterData;
- (nonnull instancetype)initWithFrame:(CGRect)frame OBJC_DESIGNATED_INITIALIZER;
- (nullable instancetype)initWithCoder:(NSCoder * _Nonnull)aDecoder OBJC_DESIGNATED_INITIALIZER;
@end


@interface UIPanGestureRecognizer (SWIFT_EXTENSION(Charts))
@end


@interface UIPinchGestureRecognizer (SWIFT_EXTENSION(Charts))
@end


@interface UIRotationGestureRecognizer (SWIFT_EXTENSION(Charts))
@end


@interface UIScreen (SWIFT_EXTENSION(Charts))
@end


@interface UITapGestureRecognizer (SWIFT_EXTENSION(Charts))
@end


@interface UIView (SWIFT_EXTENSION(Charts))
@end

#pragma clang diagnostic pop
